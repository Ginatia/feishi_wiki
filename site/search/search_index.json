{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\u5173\u4e8e","text":""},{"location":"#feishiwiki","title":"feishi\u7684wiki","text":""},{"location":"Combinatorics/combination/","title":"combination","text":""},{"location":"Combinatorics/combination/#nx","title":"\u5c06N\u7403\u653e\u5165X\u76d2\u5b50","text":"\u533a\u5206\u7403 \u533a\u5206\u76d2\u5b50 \u6ca1\u6709\u9650\u5236 \u81f3\u591a1\u4e2a \u81f3\u5c111\u4e2a 1 1 x^{N} P(N,X) X!S(N,X)=\\sum_{i=0}^{X}(-1)^{X-i}C(X,i)i^{N} 0 1 H(N,X)=C(N+X-1,N) C(N,X) H(N-X,X)=C(N-1,N-X)=C(N-1,X-1) 1 0 B(N,X)=\\sum_{i=0}^{X}S(N,i) [N\\le X] S(N,X) 0 0 p_{\\le X}(N)=\\sum_{i=0}^{X}p_i(N) [N\\le X] p_{X}(N)\\ or\\  p_{\\le X}(N-X)"},{"location":"Combinatorics/combination/#_1","title":"\u533a\u5206\u7403\uff0c\u533a\u5206\u76d2\u5b50","text":"<p>\u6ca1\u6709\u9650\u5236:</p> <p>\u4f8b\u9898</p> <p>\u90a3\u4e48\u6bcf\u4e2a\u7403\u6709 X \u4e2a\u9009\u62e9\uff0c\u9009\u62e9 N \u6b21</p> <p>\u7531\u4e58\u6cd5\u539f\u7406\uff0c\u7b54\u6848\u4e3a\uff1a X^{N}</p> <p>\u6bcf\u4e2a\u76d2\u5b50\u81f3\u591a\u5bb9\u7eb31\u4e2a\u7403:</p> <p>\u4f8b\u9898</p> <p>\u7b2c\u4e00\u4e2a\u7403\u6709 X \u9009\u62e9\uff0c\u7b2c\u4e8c\u4e2a\u7403\u6709 X-1 \u9009\u62e9\uff0c \\dots , \u7b2c N \u4e2a\u7403\u6709 X-N+1 \u4e2a\u9009\u62e9</p> <p>\u7531\u4e58\u6cd5\u539f\u7406\uff0c\u7b54\u6848\u4e3a: X(X-1)(X-2)\\dots(X-N+1)=P(N,X) , \u8ba1\u7b97\u6392\u5217 P(N,X)\u5373\u53ef</p> <p>\u6bcf\u4e2a\u76d2\u5b50\u81f3\u5c11\u5bb9\u7eb31\u4e2a\u7403</p> <p>\u4f8b\u9898</p> <p>\u5c06\u4e00\u4e2a\u6709 N \u7269\u54c1\u7684\u96c6\u5408\u5206\u4e3a X \u4e2a\u975e\u7a7a\u5b50\u96c6 \u7684\u65b9\u6cd5\u6570 \u79f0\u4e4b\u4e3a\u7b2c\u4e8c\u7c7b\u65af\u7279\u6797\u6570 S(N,X) </p> <p>\u7531\u4e8e X \u76d2\u5b50\u76f8\u4e92\u533a\u5206\uff0c\u6240\u4ee5\u7b54\u6848\u4e3a\uff1a X!S(N,X)</p> <p>S(N,X)=\\frac{1}{X!}\\sum_{i=0}^{X}(-1)^{X-i}C(X,i)i^{N}</p> <p>X!S(N,X)=\\sum_{i=0}^{X}(-1)^{X-i}C(X,i)i^{N}</p> <p>\u8fd8\u53ef\u4ee5\u901a\u8fc7\u52a8\u6001\u89c4\u5212\u8ba1\u7b97:</p> <p>S(N,X)=XS(N-1,X)+S(N-1,X-1)</p>"},{"location":"Combinatorics/combination/#_2","title":"\u4e0d\u533a\u5206\u7403\uff0c\u533a\u5206\u76d2\u5b50","text":"<p>\u4f8b\u9898</p> <p>\u6ca1\u6709\u9650\u5236</p> <p>N \u7403\u9009\u51fa X \u4e2a\u76d2\u5b50\u653e\u8fdb\u53bb\uff0c\u5141\u8bb8\u76d2\u5b50\u91cd\u590d\u9009\u62e9\u7684\u65b9\u6cd5\u6570\u79f0\u4e4b\u4e3a \u91cd\u53e0\u7ec4\u5408 H(N,X)=C(N+X-1,N)=C(N+X-1,X-1)</p> <p>\u81f3\u591a\u4e00\u4e2a</p> <p>\u4f8b\u9898</p> <p>N \u7403\u9009\u51fa X \u4e2a\u76d2\u5b50\u653e\u8fdb\u53bb\uff0c\u4e0d\u5141\u8bb8\u76d2\u5b50\u91cd\u590d\u9009\u62e9\uff0c\u5373\u4e3a\u7ec4\u5408\u6570\uff0cC(N,X)</p> <p>\u81f3\u5c11\u4e00\u4e2a</p> <p>\u4f8b\u9898</p> <p>\u7531\u4e8e\u5b58\u5728\u6bcf\u4e2a\u76d2\u5b50\u81f3\u5c11\u9700\u8981\u4e00\u4e2a\u7403\u7684\u9650\u5236\uff0c\u90a3\u4e48\u53ef\u4ee5\u6bcf\u4e2a\u76d2\u5b50\u5148\u653e\u8fdb\u53bb1\u4e2a\u7403  </p> <p>\u90a3\u4e48\u95ee\u9898\u5c31\u8f6c\u4e3a \u6ca1\u6709\u9650\u5236 \u7684\u60c5\u51b5\uff0c\u4e5f\u5c31\u662f\u91cd\u53e0\u7ec4\u5408\u7684\u60c5\u51b5  </p> <p>\u7b54\u6848\u4e3a: H(N-X,X)</p>"},{"location":"Combinatorics/combination/#_3","title":"\u533a\u5206\u7403\uff0c\u4e0d\u533a\u5206\u76d2\u5b50","text":"<p>\u6ca1\u6709\u9650\u5236</p> <p>\u4f8b\u9898</p> <p>\u5c06 N \u4e2a\u7403\u5206\u4e3a\u81f3\u591a X \u4e2a\u975e\u7a7a\u96c6\u5408\u7684\u65b9\u6cd5\u6570 \u79f0\u4e3a \u8d1d\u5c14\u6570  </p> <p>B(N,X)=\\sum_{i=0}^{X}S(N,i) </p> <p>\u81f3\u591a\u4e00\u4e2a</p> <p>\u5f53 N\\le X \u65f6\uff0c\u6240\u6709\u7403\u90fd\u653e\u5165\u76d2\u5b50\uff0c\u65b9\u6cd5\u6570\u4e3a1  </p> <p>N&gt;X \u65f6\uff0c\u4e0d\u80fd\u5c06\u6240\u6709\u7403\u653e\u5165\u76d2\u5b50\uff0c\u65b9\u6cd5\u6570\u4e3a0</p> <p>\u7b80\u8bb0\u4e3a: [N\\le X]</p> <p>\u8fd9\u4e2a\u7b26\u53f7\u4e3a \"Iverson bracket\",\u827e\u5f17\u68ee\u62ec\u53f7</p> <p>\u81f3\u5c11\u4e00\u4e2a</p> <p>\u4f8b\u9898</p> <p>\u5c06\u4e00\u4e2a\u6709 N \u7269\u54c1\u7684\u96c6\u5408\u5206\u4e3a X \u4e2a\u975e\u7a7a\u5b50\u96c6 \u7684\u65b9\u6cd5\u6570 \u79f0\u4e4b\u4e3a\u7b2c\u4e8c\u7c7b\u65af\u7279\u6797\u6570 S(N,X)</p>"},{"location":"Combinatorics/combination/#_4","title":"\u4e0d\u533a\u5206\u7403\uff0c\u4e0d\u533a\u5206\u76d2\u5b50","text":"<p>\u6ca1\u6709\u9650\u5236</p> <p>\u4f8b\u9898</p> <p>\u5c06 N \u7403 \u5212\u5206\u5230\u81f3\u591a X \u4e2a\u76d2\u5b50 \u7684\u65b9\u6cd5\u6570\u79f0\u4e4b\u4e3a \u5212\u5206\u6570</p> <p>\u6839\u636e\u516c\u5f0f: p(n,k)=p(n,k-1)+p(n-k,n) \u9884\u5148\u8ba1\u7b97p</p> <p>\u518d\u6839\u636e p_{\\le X}(N)=\\sum_{i=0}^{X}p(X,i) \u52a0\u548c\u5373\u53ef  </p> <p>\u81f3\u591a\u4e00\u4e2a</p> <p>\u4f8b\u9898</p> <p>\u6b64\u60c5\u51b5\u540c\u4e4b\u524d\u4e00\u6837\uff0c\u6545\u76f4\u63a5\u7ed9\u51fa\u7b54\u6848: [N\\le X]</p> <p>\u81f3\u5c11\u4e00\u4e2a</p> <p>\u4f8b\u9898</p> <p>\u7531\u4e8e\u6bcf\u4e2a\u90fd\u9700\u8981\u81f3\u5c11\u9700\u8981\u4e00\u4e2a  </p> <p>\u6240\u4ee5\u5148\u5bf9\u6bcf\u4e2a\u76d2\u5b50\u90fd\u653e\u4e00\u4e2a:</p> <p>\u7b54\u6848\u4e3a\uff1a p_{\\le X}(N-X) </p>"},{"location":"Combinatorics/combination/#_5","title":"\u6a21\u677f\u4ec5\u4f9b\u53c2\u8003","text":"<pre><code>using i64 = long long;\ntemplate &lt;typename T, T MOD = 1000000007&gt; struct Mint {\n    inline static constexpr T mod = MOD;\n    T v;\n    Mint() : v(0) {}\n    Mint(signed v) : v(v) {}\n    Mint(long long t) {\n        v = t % MOD;\n        if (v &lt; 0)\n            v += MOD;\n    }\n\n    Mint pow(long long k) {\n        Mint res(1), tmp(v);\n        while (k) {\n            if (k &amp; 1)\n                res *= tmp;\n            tmp *= tmp;\n            k &gt;&gt;= 1;\n        }\n        return res;\n    }\n\n    static Mint add_identity() { return Mint(0); }\n    static Mint mul_identity() { return Mint(1); }\n\n    Mint inv() { return pow(MOD - 2); }\n\n    Mint &amp;operator+=(Mint a) {\n        v += a.v;\n        if (v &gt;= MOD)\n            v -= MOD;\n        return *this;\n    }\n    Mint &amp;operator-=(Mint a) {\n        v += MOD - a.v;\n        if (v &gt;= MOD)\n            v -= MOD;\n        return *this;\n    }\n    Mint &amp;operator*=(Mint a) {\n        v = 1LL * v * a.v % MOD;\n        return *this;\n    }\n    Mint &amp;operator/=(Mint a) { return (*this) *= a.inv(); }\n\n    Mint operator+(Mint a) const { return Mint(v) += a; }\n    Mint operator-(Mint a) const { return Mint(v) -= a; }\n    Mint operator*(Mint a) const { return Mint(v) *= a; }\n    Mint operator/(Mint a) const { return Mint(v) /= a; }\n\n    Mint operator+() const { return *this; }\n    Mint operator-() const { return v ? Mint(MOD - v) : Mint(v); }\n\n    bool operator==(const Mint a) const { return v == a.v; }\n    bool operator!=(const Mint a) const { return v != a.v; }\n};\ntemplate &lt;typename T, T MOD&gt;\nstd::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, Mint&lt;T, MOD&gt; m) {\n    os &lt;&lt; m.v;\n    return os;\n}\n\nusing Z = Mint&lt;i64&gt;;\n\nstruct Combination {\n    std::vector&lt;Z&gt; fac, ifac;\n    int N;\n    Combination(int _N) : N(2 * _N), fac(2 * _N + 1), ifac(2 * _N + 1) {\n      fac[0] = Z(1);\n      for (int i = 1; i &lt;= N; i++) {\n        fac[i] = fac[i - 1] * Z(i);\n      }\n      ifac[N] = fac[N].inv();\n      for (int i = N - 1; i &gt;= 0; i--) {\n        ifac[i] = ifac[i + 1] * Z(i + 1);\n      }\n    }\n\n    Z C(int n, int k) {\n        if (n &lt; k or n &lt; 0 or k &lt; 0) {\n            return Z(0);\n        }\n        return fac[n] * ifac[n - k] * ifac[k];\n    }\n    Z P(int n, int k) {\n        if (n &lt; k or n &lt; 0 or k &lt; 0) {\n            return Z(0);\n        }\n        return fac[n] * ifac[n - k];\n    }\n    Z H(int n,int k){\n      return C(n+k-1,n);\n    }\n    Z S(int n,int k){\n      Z ans=0;\n      for(i64 i=0;i&lt;=k;i++){\n        if((k-i)%2==0){\n          ans+=C(k,i)*Z(i).pow(n);\n        }\n        else{\n          ans-=C(k,i)*Z(i).pow(n);\n        }\n      }\n      return ans*ifac[k];\n    }\n};\n\n</code></pre>"},{"location":"atc/ABC006/","title":"ABC006","text":"<p>A - \u4e16\u754c\u306eFizzBuzz</p> <p>\u82e5 3|N\uff0c\u8f93\u51faYES\uff0c\u5426\u5219\u8f93\u51faNO </p> <p>B - \u30c8\u30ea\u30dc\u30ca\u30c3\u30c1\u6570\u5217</p> <p>\u8f93\u51fa\u6590\u6ce2\u90a3\u5951\u6570\u5217\u7684\u7b2cN\u9879\uff0c\u5e76\u5bf910007\u53d6\u6a21 </p> <p>C - \u30b9\u30d5\u30a3\u30f3\u30af\u30b9\u306e\u306a\u305e\u306a\u305e </p> <p>x+y+z=N </p> <p>2x+3y+4z=M </p> <p>N\\le 10^5,M\\le 5\\times 10^5 </p> <p>\u89e3\u65b9\u7a0b\u7ec4\uff0c\u82e5\u65e0\u89e3\uff0c\u5219\u8f93\u51fa-1 -1 -1</p> <p>\u7531\u4e8e\u8fd9\u662f\u4e00\u4e2a\u6b20\u5b9a\u7ebf\u6027\u65b9\u7a0b\u7ec4\uff0c\u6545\u679a\u4e3ez\u4e4b\u540e\uff0c\u5c31\u4e3a\u4e00\u4e2a\u9002\u5b9a\u7ebf\u6027\u65b9\u7a0b\u7ec4 </p> <p>x=3N-M+z,y=M-2N-2z </p> <p>D - \u30c8\u30e9\u30f3\u30d7\u633f\u5165\u30bd\u30fc\u30c8 </p> <p>\u6709N\u957f\u7684\u5e8f\u5217\uff0c\u6bcf\u6b21\u62ff\u51fa\u4e00\u4e2a\u6570\u5e76\u5c06\u5176\u63d2\u5165\u5230\u5e8f\u5217\uff0c\u8bf7\u95ee\u5c06\u5e8f\u5217\u5347\u5e8f\u6392\u5e8f\u6240\u9700\u7684\u6700\u5c11\u7684\u64cd\u4f5c\u6b21\u6570 </p> <p>\u6ce8\u610f\u5230,\u6bcf\u6b21\u64cd\u4f5c\u90fd\u4e0d\u5f71\u54cd\u5e8f\u5217\u5176\u4ed6\u7684\u6570\u7684\u76f8\u5bf9\u6b21\u5e8f</p> <p>\u6240\u4ee5\u5982\u679c\u627e\u5230\u4e00\u4e2aLIS(\u6700\u957f\u4e0a\u5347\u5b50\u5e8f\u5217),\u5219\u5269\u4e0b\u7684\u6570\u7684\u96c6\u5408\u4e2a\u6570\u5373\u4e3a\u6700\u5c11\u64cd\u4f5c\u6b21\u6570</p> <p>\u7b54\u6848\u5373\u4e3a:N-LIS </p> <pre><code>int LIS(std::vector&lt;int&gt;&amp;a){\n  int n=(int)a.size();\n  int INF=std::numeric_limits&lt;int&gt;::max();\n  std::vector&lt;int&gt;dp(n,INF);\n  for(int i=0;i&lt;n;i++){\n    *std::lower_bound(dp.begin(),dp.end(),a[i])=a[i];\n  }\n  return std::lower_bound(dp.begin(),dp.end(),INF)-dp.begin();\n}\nvoid solve() {\n  int n;std::cin&gt;&gt;n;\n  std::vector&lt;int&gt;a(n);\n  for(auto&amp;x:a){\n    std::cin&gt;&gt;x;\n  }\n  std::cout&lt;&lt;n-LIS(a)&lt;&lt;'\\n';\n}\n</code></pre>"},{"location":"atc/ABC015/","title":"ABC015","text":"<p>A - \u9ad8\u6a4b\u304f\u3093\u306e\u7814\u4fee</p> <p>\u7ed9\u5b9a\u4e24\u5b57\u7b26\u4e32\uff0c\u8f93\u51fa\u957f\u5ea6\u6700\u957f\u7684\u5b57\u7b26\u4e32\uff0c\u4fdd\u8bc1\u4e24\u5b57\u7b26\u4e32\u957f\u5ea6\u4e0d\u4e00\u6837  </p> <pre><code>void solve()\n{\n    std::string a,b;\n    std::cin&gt;&gt;a&gt;&gt;b;\n    std::cout&lt;&lt;(a.size()&gt;b.size()?a:b)&lt;&lt;'\\n';\n}\n\n</code></pre> <p>B - \u9ad8\u6a4b\u304f\u3093\u306e\u96c6\u8a08 </p> <p>\u6709N\u4e2a\u8f6f\u4ef6\uff0c\u6bcf\u4e2a\u8f6f\u4ef6\u6709 A_i \u4e2abug\uff0c\u82e5 A_i=0 \u8bf4\u660e\u7b2c i \u4e2a\u8f6f\u4ef6\u6ca1\u6709bug  </p> <p>\u6c42 \u51fa\u9519\u7684\u8f6f\u4ef6\u5e73\u5747\u7684bug\u6570\uff0c\u5e76\u5411\u4e0a\u53d6\u6574  </p> <pre><code>void solve()\n{\n    int N;std::cin&gt;&gt;N;\n    std::vector&lt;int&gt;a(N);\n    for(auto&amp;x:a)std::cin&gt;&gt;x;\n    int s=std::accumulate(a.begin(),a.end(),0);\n    int M=std::accumulate(a.begin(),a.end(),0,[&amp;](int ans,int x){\n        return ans+(x!=0);\n    });\n    int ans=(s+M-1)/M;\n    std::cout&lt;&lt;ans&lt;&lt;'\\n';\n}\n\n</code></pre> <p>C - \u9ad8\u6a4b\u304f\u3093\u306e\u30d0\u30b0\u63a2\u3057 </p> <p>\u6709N\u6b21\u9009\u62e9\uff0c\u6bcf\u6b21\u6709K\u4e2a\u9009\u62e9\u65b9\u6848\uff0c\u82e5\u9009\u62e9\u7684\u6240\u6709\u6570\u5f02\u6216\u503c=0,\u90a3\u4e48\u8bf4\u660e\u51fa\u73b0\u9519\u8bef  </p> <p>\u95ee\u7ed9\u5b9a\u7684\u95ee\u9898\u662f\u5426\u4f1a\u5bfc\u81f4\u9519\u8bef\uff1f</p> <p>N\uff0cK \\le 5  \u641c\u7d22\u5373\u53ef</p> <pre><code>void solve()\n{\n    int N,K;std::cin&gt;&gt;N&gt;&gt;K;\n    std::vector a(N,std::vector(K,0));\n    for(int i=0;i&lt;N;i++){\n        auto&amp;v=a[i];\n        for(auto&amp;x:v)std::cin&gt;&gt;x;\n    }\n\n    bool ok=true;\n    auto dfs=[&amp;](auto self,int i,int cur)-&gt;void{\n        if(i==N){\n            ok=(cur==0?false:ok);\n            return;\n        }\n        for(int j=0;j&lt;K;j++){\n            self(self,i+1,cur^a[i][j]);\n        }\n    };\n    dfs(dfs,0,0);\n    std::cout &lt;&lt; (ok ? \"Nothing\" : \"Found\")&lt;&lt;'\\n';\n}\n\n</code></pre> <p>D - \u9ad8\u6a4b\u304f\u3093\u306e\u82e6\u60a9 </p> <p>\u6709N\u4e2a\u7269\u54c1\uff0c\u6700\u591a\u9009K\u4e2a  </p> <p>\u7269\u54c1\u6709\u91cd\u91cf\u4e3a A_i ,\u4ef7\u503c\u4e3a B_i </p> <p>\u4fdd\u8bc1 \\sum A_i \\le W </p> <p>\u6700\u5927\u5316 \uff1a \\sum B_i </p> <p>\u6bcf\u4e2a\u7269\u54c1\u53ea\u80fd\u7528\u4e00\u6b21\uff0c\u53c8\u6700\u591a\u9009K\u4e2a\uff0c\u91cd\u91cf\u6700\u5927\u4e3a W </p> <p>\u90a3\u4e48\u95ee\u9898\u5f52\u7ed3\u4e8e 01\u80cc\u5305\uff0c\u6709\u4e24\u4e2a\u8d39\u7528\uff0c\u5206\u522b\u4e3a\u9009\u62e9\u4e2a\u6570\u4e0e\u91cd\u91cf\u4e4b\u548c  </p> <p>dp[w][k]=max(dp[w][k],dp[w-A[i]][k-1]+B[i]) </p> <pre><code>template &lt;typename T&gt; inline bool chmin(T &amp;a, T &amp;&amp;b) {\n  if (a &gt; b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\ntemplate &lt;typename T&gt; inline bool chmax(T &amp;a, T &amp;&amp;b) {\n  if (a &lt; b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\nvoid solve()\n{\n\n    int N,W,K;std::cin&gt;&gt;W&gt;&gt;N&gt;&gt;K;\n    std::vector&lt;int&gt;A(N+1),B(N+1);\n    for(int i=1;i&lt;=N;i++){\n        std::cin&gt;&gt;A[i]&gt;&gt;B[i];\n    }\n    std::vector dp(W+1,std::vector(N+1,0));\n\n    for(int i=1;i&lt;=N;i++){\n        for(int w=W;w&gt;=A[i];w--){\n            for(int k=K;k&gt;=1;k--){\n                chmax(dp[w][k],dp[w-A[i]][k-1]+B[i]);                \n            }\n        }\n    }\n    std::cout&lt;&lt;dp[W][K]&lt;&lt;'\\n';\n}\n\n</code></pre>"},{"location":"atc/ABC016/","title":"ABC016","text":"<p>C - \u53cb\u9054\u306e\u53cb\u9054</p> <p>\u5c06\u670b\u53cb\u5173\u7cfb\u62bd\u8c61\u4e3a\u8fb9\uff0c\u627e\u5230\u6700\u5c0f\u8ddd\u79bb\u4e3a2\u7684\u6240\u6709\u670b\u53cb\u5173\u7cfb\u5373\u53ef  </p> <pre><code>#include &lt;bits/stdc++.h&gt;\n#include &lt;limits&gt;\n#include &lt;vector&gt;\nusing i64 = long long;\n\ntemplate &lt;typename T&gt; struct Dijkstra {\n    struct Edge {\n        int to;\n        T cost;\n        Edge(int _to, T _cost) : to(_to), cost(_cost) {}\n        bool operator&lt;(const Edge &amp;o) const { return cost &gt; o.cost; }\n    };\n    std::vector&lt;std::vector&lt;Edge&gt;&gt; G;\n    std::vector&lt;T&gt; ds;\n    std::vector&lt;int&gt; bs;\n    Dijkstra(int n) : G(n) {}\n\n    void add_edge(int u, int v, T c) { G[u].emplace_back(v, c); }\n    void build(int s) {\n        int n = G.size();\n        ds.assign(n, std::numeric_limits&lt;T&gt;::max());\n        bs.assign(n, -1);\n        std::priority_queue&lt;Edge&gt; pq;\n        ds[s] = 0;\n        pq.emplace(s, ds[s]);\n        while (not pq.empty()) {\n            auto [u, cost_u] = pq.top();\n            pq.pop();\n            if (ds[u] &lt; cost_u) {\n                continue;\n            }\n            for (auto [v, cost_v] : G[u]) {\n                if (ds[v] &gt; ds[u] + cost_v) {\n                    ds[v] = ds[u] + cost_v;\n                    bs[v] = u;\n                    pq.emplace(v, ds[v]);\n                }\n            }\n        }\n    }\n\n    T operator[](int k) { return ds[k]; }\n    std::vector&lt;int&gt; restore(int to) {\n        std::vector&lt;int&gt; ans;\n        if (bs[to] &lt; 0) {\n            return ans;\n        }\n        while (~to) {\n            ans.emplace_back(to);\n            to = bs[to];\n        }\n        std::reverse(ans.begin(), ans.end());\n        return ans;\n    }\n};\n\nvoid solve()\n{\n  int N,M;\n  std::cin&gt;&gt;N&gt;&gt;M;\n  Dijkstra&lt;int&gt;g(N);\n  for(int i=0;i&lt;M;i++){\n    int a,b;\n    std::cin&gt;&gt;a&gt;&gt;b;\n    --a,--b;\n    g.add_edge(a, b, 1);\n    g.add_edge(b, a, 1);\n  }\n  auto calc=[&amp;](int s){\n    g.build(s);\n    int ans=0;\n    for(int i=0;i&lt;N;i++){\n      ans+=g[i]==2;\n    }\n    return ans;\n  };\n  for(int i=0;i&lt;N;i++){\n    std::cout&lt;&lt;calc(i)&lt;&lt;'\\n';\n  }\n}\nint main()\n{\n    std::cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    solve();\n}\n</code></pre>"},{"location":"atc/ABC036/","title":"ABC036","text":"<p>A - \u304a\u8336</p> <p>\u4e00\u4e2a\u7bb1\u5b50A\u4e2a\u74f6\u5b50\uff0c\u8981\u4e70B\u4e2a\u74f6\u5b50\u9700\u8981\u4e70\u51e0\u4e2a\u7bb1\u5b50  </p> <p>\u5411\u4e0a\u53d6\u6574\u5373\u53ef</p> <pre><code>void solve()\n{\n  int A,B;std::cin&gt;&gt;A&gt;&gt;B;\n  std::cout&lt;&lt;(B+A-1)/A&lt;&lt;'\\n';\n}\n</code></pre> <p>B - \u56de\u8ee2</p> <p>\u6709\u4e00\u4e2a N \\times N \u7684\u65b9\u9635\uff0c\u5c06\u5176\u987a\u65f6\u9488\u65cb\u8f6c90\u5ea6  </p> <p>\u6a21\u62df\u5373\u53ef</p> <pre><code>void solve()\n{\n    int n;std::cin&gt;&gt;n;\n    std::vector&lt;std::string&gt;a(n),b;\n    b.reserve(n);\n    for(auto&amp;i:a)std::cin&gt;&gt;i;\n    for(int j=0;j&lt;n;j++)\n    {\n        std::string s;\n        for(int i=0;i&lt;n;i++)\n        {\n            s+=a[i][j];\n        }\n        std::reverse(s.begin(),s.end());\n        b.push_back(s);\n    }\n    for(const auto&amp;i:b){std::cout&lt;&lt;i&lt;&lt;\"\\n\";}\n}\n</code></pre> <p>C - \u5ea7\u5727</p> <p>N\u4e2a\u6570\uff0c\u5c06\u6570\u5217 a_i \u7684\u503c\u538b\u7f29\u4e3a\u76f8\u5bf9\u6b21\u5e8f  </p> <p>\u4e8c\u5206\u67e5\u627e\u6216map\u538b\u7f29</p> <pre><code>void solve()\n{\n  int n;std::cin&gt;&gt;n;\n  std::vector&lt;int&gt;a(n);\n  for(auto&amp;x:a){\n    std::cin&gt;&gt;x;\n  }\n  auto v=a;\n  std::sort(v.begin(),v.end());\n  v.erase(std::unique(v.begin(),v.end()),v.end());\n\n  for(auto x:a){\n    std::cout&lt;&lt;std::lower_bound(v.begin(),v.end(),x)-v.begin()&lt;&lt;'\\n';\n  }\n}\n\n</code></pre> <p>D - \u5857\u308a\u7d75</p> <p>\u6709N\u4e2a\u70b9\u7684\u6811\uff0c\u5c06\u70b9\u67d3\u6210\u9ed1\u6216\u8005\u767d\uff0c\u4f46\u4e0d\u80fd\u51fa\u73b0\u4e00\u6761\u8fb9\u540c\u4e3a\u9ed1\uff0c\u53d6\u6a21 10^9+7 </p> <p>\u6811dp</p> <pre><code>void solve()\n{\n  int N;std::cin&gt;&gt;N;\n  std::vector&lt;std::vector&lt;int&gt;&gt;g(N);\n  for(int i=1;i&lt;N;i++){\n    int a,b;\n    std::cin&gt;&gt;a&gt;&gt;b;\n    --a,--b;\n    g[a].push_back(b);\n    g[b].push_back(a);\n  }\n  std::vector&lt;std::array&lt;Z, 2&gt;&gt;dp(N,{Z(1),Z(1)});\n\n  auto dfs=[&amp;](auto self,int u,int f)-&gt;void{\n    for(const auto&amp;v:g[u]){\n      if(v==f){\n        continue;\n      }\n      self(self,v,u);\n      dp[u][0]*=dp[v][0]+dp[v][1];\n      dp[u][1]*=dp[v][0];\n    }\n  };\n\n  dfs(dfs,0,-1);\n  std::cout&lt;&lt;dp[0][0]+dp[0][1]&lt;&lt;'\\n';\n}\n\n</code></pre>"},{"location":"atc/ABC110/","title":"ABC110","text":"<p>D - Factorization</p> <p>\u7ed9\u5b9a\u6b63\u6574\u6570 N,M,\u4e14  </p> <p>a_1 \\times a_2 \\times \\cdots a_n = M</p> <p>\u95ee\u6709\u591a\u5c11\u79cd\u8fd9\u6837\u7684\u5e8f\u5217a\uff0c\u5bf91e9+7 \u53d6\u6a21 </p> <p>\u5c06M\u7d20\u56e0\u5b50\u5206\u89e3  </p> <p>M=p_1^{a_1}p_2^{a_2} \\dots p_k^{a_k}</p> <p>\u539f\u547d\u9898\u7b49\u4ef7\u4e8e \u5bf9\u4e8e\u6240\u6709\u8d28\u56e0\u5b50 p_i^{a_i} \u5c06\u5176\u5206\u914d\u7ed9 N \u4e2a\u5143\u7d20 </p> <p>$\u4e5f\u5c31\u662f b_1 + b_2 + \\cdots b_n = a_i ,b \u662f\u7b2ci\u4e2a\u4f4d\u7f6e\u7684p_i\u6709\u591a\u5c11\u4e2a\uff0cb_i \\ge 0 $  </p> <p>\u5bf9\u4e8e\u5206\u914d\u4e00\u4e2a\u7d20\u56e0\u5b50 p_i^{a_i},\u6709 \\binom{N+a_i-1}{N}\u79cd\u53ef\u80fd</p> <p>\u7531\u4e8e\u7d20\u56e0\u5b50\u4e4b\u95f4\u72ec\u7acb\uff0c\u6545\u4e58\u6cd5\u539f\u7406\u5373\u53ef  </p> <pre><code>std::vector&lt;std::pair&lt;i64,i64&gt;&gt; divsor(i64 N){\n    std::vector&lt;std::pair&lt;i64,i64&gt;&gt;ans;\n    for(i64 i=2;i*i&lt;=N;i++){\n        if(N%i)continue;\n        int exp=0;\n        while(N%i==0){\n            N/=i;\n            exp++;\n        }\n        ans.emplace_back(i,exp);\n    }\n    if(N&gt;1){\n        ans.emplace_back(N,1);\n    }\n    return ans;\n}\n\nvoid solve()\n{\n    int N,M;\n    std::cin&gt;&gt;N&gt;&gt;M;\n    Z ans=1;\n    auto ds=divsor(M);\n    for(auto[_,x]:ds){\n        ans*=Comb.C(N+x-1,x);\n    }\n    std::cout&lt;&lt;ans&lt;&lt;'\\n';\n}\n\n</code></pre>"},{"location":"atc/ABC127/","title":"ABC127","text":"<p>E - Cell Distance</p> <p>\u6709\u4e00\u4e2a N\\times M \u7684\u68cb\u76d8  </p> <p>\u6709 K \u4e2a\u68cb\u5b50  </p> <p>\u628a K \u4e2a\u68cb\u5b50\u653e\u5728\u68cb\u76d8\u4e0a\uff0c\u5750\u6807\u4e3a(x_1,y_1),(x_2,y_2),\\ldots,(x_k,y_k) </p> <p>\u8ba1\u7b97 \\sum_{i=1}^{K-1}\\sum_{j=i+1}^{K}(|x_i-x_j|+|y_i-y_j|) </p> <p>\u5bb9\u6613\u53d1\u73b0 x,y \u662f\u72ec\u7acb\u8d21\u732e\u7684  </p> <p>\u9996\u5148\u786e\u5b9a\u4e24\u4e2a\u68cb\u5b50\u5206\u522b\u4e3a (x_i,y_i),(x_j,y_j) </p> <p>\u56fa\u5b9a\u8fd9\u4e24\u4e2a\u68cb\u5b50\u540e,\u5269\u4e0b\u68cb\u5b50\u7684\u79cd\u6570\u4e3a:C(NM-2,K-2)</p> <p>\u8bb0 d=|x_i-x_j| </p> <p>\u4e0d\u59a8\u8bbe x_i&lt;x_j </p> <p>d=x_j-x_i \\rightarrow x_i+d=x_j </p> <p>\u7531\u4e8e 1\\leq x_i,x_j\\leq N </p> <p>\u90a3\u4e48 1\\leq x_i\\leq N-d </p> <p>\u4e5f\u5c31\u662f\u8bf4\u5bf9\u4e8e\u4e00\u4e2ai\uff0c\u6709N-d \u4e2aj\u7b26\u5408\u7b54\u6848 </p> <p>\u53c8\u56e0\u4e3a\u6211\u4eec\u53ea\u8003\u8651\u4e86x\u5750\u6807  </p> <p>\u6b64\u65f6y\u5750\u6807\u53ef\u4ee5\u4efb\u9009  </p> <p>\u90a3\u4e48\u6709 M^{2} \u79cd\u65b9\u6848  </p> <p>\u5728x\u4e0a\u7684\u8d21\u732e\u4e3a:</p> <p>ans_x=M^{2}\\sum_{i=1}^{N-1}i\\times(N-i) </p> <p>\u540c\u7406\u5bf9\u5728y\u4e0a\u7684\u8d21\u732e\u4e3a:</p> <p>ans_y=N^{2}\\sum_{i=1}^{M-1}i\\times(M-i)</p> <p>\u603b\u7684\u8d21\u732e\u4e3a:</p> <p>ans=C(NM-2,K-2)\\times(ans_x+ans_y)</p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing i64 = long long;\n\ntemplate &lt;typename T, T MOD = 1000000007&gt; struct Mint {\n    inline static constexpr T mod = MOD;\n    T v;\n    Mint() : v(0) {}\n    Mint(signed v) : v(v) {}\n    Mint(long long t) {\n        v = t % MOD;\n        if (v &lt; 0)\n            v += MOD;\n    }\n\n    Mint pow(long long k) {\n        Mint res(1), tmp(v);\n        while (k) {\n            if (k &amp; 1)\n                res *= tmp;\n            tmp *= tmp;\n            k &gt;&gt;= 1;\n        }\n        return res;\n    }\n\n    static Mint add_identity() { return Mint(0); }\n    static Mint mul_identity() { return Mint(1); }\n\n    Mint inv() { return pow(MOD - 2); }\n\n    Mint &amp;operator+=(Mint a) {\n        v += a.v;\n        if (v &gt;= MOD)\n            v -= MOD;\n        return *this;\n    }\n    Mint &amp;operator-=(Mint a) {\n        v += MOD - a.v;\n        if (v &gt;= MOD)\n            v -= MOD;\n        return *this;\n    }\n    Mint &amp;operator*=(Mint a) {\n        v = 1LL * v * a.v % MOD;\n        return *this;\n    }\n    Mint &amp;operator/=(Mint a) { return (*this) *= a.inv(); }\n\n    Mint operator+(Mint a) const { return Mint(v) += a; }\n    Mint operator-(Mint a) const { return Mint(v) -= a; }\n    Mint operator*(Mint a) const { return Mint(v) *= a; }\n    Mint operator/(Mint a) const { return Mint(v) /= a; }\n\n    Mint operator+() const { return *this; }\n    Mint operator-() const { return v ? Mint(MOD - v) : Mint(v); }\n\n    bool operator==(const Mint a) const { return v == a.v; }\n    bool operator!=(const Mint a) const { return v != a.v; }\n};\ntemplate &lt;typename T, T MOD&gt;\nstd::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, Mint&lt;T, MOD&gt; m) {\n    os &lt;&lt; m.v;\n    return os;\n}\nusing Z = Mint&lt;i64&gt;;\n\nstruct Combination {\n    std::vector&lt;Z&gt; fac, ifac;\n    int N;\n    Combination(int _N) : N(2 * _N), fac(2 * _N + 1), ifac(2 * _N + 1) {\n      fac[0] = Z(1);\n      for (int i = 1; i &lt;= N; i++) {\n        fac[i] = fac[i - 1] * Z(i);\n      }\n      ifac[N] = fac[N].inv();\n      for (int i = N - 1; i &gt;= 0; i--) {\n        ifac[i] = ifac[i + 1] * Z(i + 1);\n      }\n    }\n\n    Z C(int n, int k) {\n        if (n &lt; k or n &lt; 0 or k &lt; 0) {\n            return Z(0);\n        }\n        return fac[n] * ifac[n - k] * ifac[k];\n    }\n    Z P(int n, int k) {\n        if (n &lt; k or n &lt; 0 or k &lt; 0) {\n            return Z(0);\n        }\n        return fac[n] * ifac[n - k];\n    }\n    Z H(int n,int k){\n      return C(n+k-1,n);\n    }\n    Z S(int n,int k){\n      Z ans=0;\n      for(i64 i=0;i&lt;=k;i++){\n        if((k-i)%2==0){\n          ans+=C(k,i)*Z(i).pow(n);\n        }\n        else{\n          ans-=C(k,i)*Z(i).pow(n);\n        }\n      }\n      return ans*ifac[k];\n    }\n}Comb(2e5+1e3);\n\nvoid solve()\n{\n  int N,M,K;\n  std::cin&gt;&gt;N&gt;&gt;M&gt;&gt;K;\n\n  Z x=0;\n  for(int i=1;i&lt;=N-1;i++){\n    x+=1LL*i*(N-i);\n  }\n  x*=Z(M).pow(2);\n  Z y=0;\n  for(int i=1;i&lt;=M-1;i++){\n    y+=1LL*i*(M-i);\n  }\n  y*=Z(N).pow(2);\n  Z ans=(x+y)*Comb.C(N*M-2, K-2);\n  std::cout&lt;&lt;ans&lt;&lt;'\\n';\n}\nint main()\n{\n    std::cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    solve();\n}\n\n</code></pre>"},{"location":"atc/ABC128/","title":"ABC128","text":"<p>E - Roadwork</p> <p>N\u4e2a\u969c\u788d\u7269\u5728 [S,T) \u65f6\u523b\u51fa\u73b0\u5728 X \u4f4d\u7f6e\u5904 Q \u4e2a\u4eba\u4ece0\u5904,D \u65f6\u523b\u51fa\u53d1\uff0c\u6bcf\u79d2\u8d70\u4e00\u6b65\uff0c\u8bf7\u6c42\u4ed6\u80fd\u8d70\u5230\u54ea\u91cc\uff1f\u82e5\u53ef\u4ee5\u4e00\u76f4\u8d70\uff0c\u8f93\u51fa-1  </p> <p>\u5047\u8bbe\u4e00\u4e2a\u4eba\u88ab\u963b\u788d\u5728 X \u4f4d\u7f6e\uff0c\u90a3\u4e48\u4ed6\u81f3\u5c11\u8d70\u4e86 X \u79d2 \u53cd\u8fc7\u6765\u8003\u8651\u4e00\u4e2a\u969c\u788d\u53ef\u4ee5\u963b\u788d\u54ea\u4e9b\u4eba \u4e00\u5b9a\u662f\u8d70\u4e86\u5728 [S-X,T-X) \u533a\u95f4\u5185 \u79bb\u7ebf\u8be2\u95ee\u5373\u53ef  </p> <pre><code>void solve()\n{\n    int n,q;std::cin&gt;&gt;n&gt;&gt;q;\n    std::vector&lt;T&gt;a(n);\n    for(auto&amp;[x,s,t]:a){\n        std::cin&gt;&gt;s&gt;&gt;t&gt;&gt;x;\n        s-=x;\n        t-=x;\n    }\n    std::sort(a.begin(), a.end());\n    std::set&lt;P&gt;se;\n    for(int i=0;i&lt;q;i++){\n        int d;std::cin&gt;&gt;d;\n        se.insert(P{d,i});\n    }\n    std::vector&lt;int&gt;ans(q,-1);\n    for(auto[x,l,r]:a){\n        auto it=se.lower_bound(P{l,-1});\n        while(it!=se.end()){\n            if(it-&gt;first&gt;=r){\n                break;\n            }\n            ans[it-&gt;second]=x;\n            se.erase(it++);\n        }\n    }\n    for(int i=0;i&lt;q;i++){\n        std::cout&lt;&lt;ans[i]&lt;&lt;\"\\n\";\n    }\n}\n</code></pre>"},{"location":"atc/ABC133/","title":"ABC133","text":"<p>E - Virus Tree 2</p> <p>\u6709\u4e00\u68f5\u7ed3\u70b9\u6570\u4e3aN\u7684\u6811\uff0c\u6709 K \u79cd\u989c\u8272 \u4e3a\u5176\u67d3\u8272\uff0c\u4f7f\u5f97\u6bcf\u5bf9 \u8ddd\u79bb\u4e0d\u8d85\u8fc72 \u7684\u9876\u70b9\u7684\u989c\u8272\u4e0d\u4e00\u6837 \u8bf7\u95ee\u6709\u591a\u5c11\u79cd\u67d3\u8272\u6cd5  </p> <p>\u5bf9\u4e8e\u6811\u6839\u6765\u8bf4\uff0c\u4ed6\u6709K\u79cd\u67d3\u8272\u6cd5,\u4e14\u4ed6\u9700\u8981\u67d3\u8272\u81ea\u5df1 (+1)  \u5bf9\u4e8e\u5176\u4ed6\u70b9\u6765\u8bf4\uff0c\u8ddd\u79bb\u4e0d\u8d85\u8fc72,\u610f\u5473\u7740\u6709\u4e24\u4e2a\u989c\u8272\u5df2\u7ecf\u88ab\u7528\u8fc7\uff0c\u4e5f\u5c31\u662f\u8bf4\u6709K-2\u79cd\u67d3\u8272\u6cd5\uff0c\u4e14\u4ed6\u9700\u8981\u9664\u5f00\u7236\u4eb2(-1)  </p> <p>\u6216\u8005\u8bf4\u5148\u786e\u5b9a\u6811\u6839\u7684\u67d3\u8272\u6cd5\u4e3aK\uff0c\u518d\u786e\u5b9a\u5176\u4ed6\u513f\u5b50\u7684\u67d3\u8272\u6cd5\uff0c \u6839\u7684\u513f\u5b50\u7684\u67d3\u8272\u6cd5\u4e3aK-1,\u5176\u4ed6\u7684\u4e3aK-2 </p> <p>\u7531\u4e8e\u6bcf\u4e2a\u7ed3\u70b9\u4e0d\u4e00\u6837\uff0c\u67d3\u8272\u662f\u4e00\u4e2a\u6392\u5217\u95ee\u9898 ans*=P(\u989c\u8272\u6570,\u513f\u5b50\u6570) </p> <pre><code>void solve() {\n    int n, k;\n    std::cin &gt;&gt; n &gt;&gt; k;\n    std::vector g(n, std::vector&lt;int&gt;());\n    for (int i = 1; i &lt; n; i++) {\n        int u, v;\n        std::cin &gt;&gt; u &gt;&gt; v;\n        --u, --v;\n        g[u].emplace_back(v);\n        g[v].emplace_back(u);\n    }\n    Z ans = 1;\n    const int NIL = -1;\n    auto dfs = [&amp;](auto self, int u, int f) -&gt; void {\n        for (const auto &amp;v : g[u]) {\n            if (v == f) {\n                continue;\n            }\n            self(self, v, u);\n        }\n        int x = (f == NIL) ? k : k - 2;\n        int y = (f == NIL) ? g[u].size() + 1 : g[u].size() - 1;\n        ans *= Comb.P(x, y);\n    };\n    dfs(dfs, 0, NIL);\n    std::cout &lt;&lt; ans &lt;&lt; '\\n';\n}\n\n</code></pre>"},{"location":"atc/ABC152/","title":"ABC152","text":"<p>D - Handstand 2</p> <p>\u7ed9\u5b9aN,\u6c42\u5f97\u6ee1\u8db3\u6761\u4ef6\u7684\u6574\u6570\u7ec4(A,B)\u7684\u4e2a\u6570 </p> <p>A\u7684\u9996\u4f4d\u6570\u4f4d=B\u7684\u672b\u5c3e\u6570\u4f4d\uff0cA\u7684\u672b\u5c3e\u6570\u4f4d=B\u7684\u9996\u4f4d\u6570\u4f4d </p> <p>\u8bbe\u4e00\u4e2a\u6570\u7684\u9996\u4f4d\u6570\u4f4d\u4e0e\u672b\u5c3e\u6570\u4f4d\u4e3a(x,y) </p> <p>\u5219A:x...y=B:y...x </p> <p>\u8bb0\u5f551-N\u6bcf\u4e2a\u6570\u7684\u9996\u4f4d\u4e0e\u672b\u5c3e\u6570\u4f4d\u7684\u8d21\u732e\u6b21\u6570cnt[x][y] </p> <p>\u679a\u4e3e\u6570\u4f4d\u7ec4A=(x,y),B=(y,x) </p> <pre><code>using i64 = long long;\nstd::pair&lt;int, int&gt;get(int x){\n  std::string s=std::to_string(x);\n  int a=s.front()-'0';\n  int b=s.back()-'0';\n  return {a,b};\n}\nvoid solve() {\n  int n;std::cin&gt;&gt;n;\n  std::vector&lt;std::array&lt;int, 10&gt;&gt;cnt(10);\n  for(int i=1;i&lt;=n;i++){\n    auto[x,y]=get(i);\n    cnt[x][y]++;\n  }\n  i64 ans=0;\n  for(int x=0;x&lt;=9;x++){\n    for(int y=0;y&lt;=9;y++){\n      ans+=cnt[x][y]*cnt[y][x];\n    }\n  }\n  std::cout&lt;&lt;ans&lt;&lt;'\\n';\n}\n\n</code></pre> <p>E - Flatten</p> <p>A_iB_i=A_jB_j=K</p> <p>B_i=\\frac{K}{A_i},B_j=\\frac{K}{A_j} </p> <p>i\\in[1,n],A_i|K </p> <p>K=lcm(A)</p> <p>ans=\\sum_{i=1}^{N}\\frac{K}{A_i} \\mod {10^9+7}</p> <p>\u7531\u4e8e\u76f4\u63a5\u6309\u7167\u516c\u5f0f\u6c42lcm,\u4e2d\u95f4\u7ed3\u679c\u4f1a\u51fa\u73b0\u5927\u6574\u6570\u7684\u60c5\u51b5 </p> <p>\u65b9\u68481:\u4f7f\u7528python</p> <p>\u65b9\u68482:\u5206\u89e3A_i,\u5f97\u5230\u5176\u8d28\u56e0\u5b50\u5206\u89e3\uff0c\u6c42\u5f97\u6bcf\u4e2a\u8d28\u56e0\u5b50\u7684\u6700\u5927\u5e42\u6b21\u5373\u53ef </p> <pre><code>from functools import reduce\nfrom math import gcd\ndef LI():\n    return list(map(int, input().split()))\n\ndef I():\n    return int(input())\n\ndef solve():\n    N=I()\n    a=LI()\n    lcm=reduce(lambda x,y:x//gcd(x,y)*y,a)\n    MOD=10**9+7\n    ans = sum((lcm//x)%MOD for x in a)%MOD\n    print(ans)\n\nsolve()\n\n</code></pre> <pre><code>void solve() {\n  int n;\n  std::cin&gt;&gt;n;\n  std::vector&lt;int&gt;a(n);\n  for(auto&amp;x:a){\n    std::cin&gt;&gt;x;\n  }\n  std::map&lt;int, int&gt;cnt;\n\n  auto prime_div=[&amp;](int x){\n    for(int i=2;i*i&lt;=x;i++){\n      if(x%i)continue;\n      int exp=0;\n      while (x%i==0) {\n        exp++;\n        x/=i;\n      }\n      if(cnt.find(i)!=cnt.end()){\n        cnt[i]=std::max(cnt[i],exp);\n      }\n      else{\n        cnt[i]=exp;\n      }\n    }\n    if (cnt.find(x) != cnt.end()) {\n      cnt[x] = std::max(cnt[x], 1);\n    } else {\n      cnt[x] = 1;\n    }\n    return;\n  };\n  for(const auto&amp;x:a){\n    prime_div(x);\n  }\n  Z lcm=1;\n  for(auto&amp;[x,y]:cnt){\n    lcm*=Z(x).pow(y);\n  }\n  Z ans=0;\n  for(auto&amp;x:a){\n    ans+=lcm/Z(x);\n  }\n  std::cout&lt;&lt;ans&lt;&lt;'\\n';\n}\n</code></pre>"},{"location":"atc/ABC160/","title":"ABC160","text":"<p>E - Red and Green Apples</p> <p>\u9700\u8981X\u4e2a\u7ea2\u82f9\u679c\uff0cY\u4e2a\u7eff\u82f9\u679c\uff0c\u6bcf\u4e2a\u82f9\u679c\u90fd\u6709\u7f8e\u5473\u503c \u4e00\u5171\u6709A\u4e2a\u7ea2\u82f9\u679c\uff0cB\u4e2a\u7eff\u82f9\u679c\uff0cC\u4e2a\u65e0\u8272\u82f9\u679c \u53ef\u4ee5\u5c06\u65e0\u8272\u82f9\u679c\u67d3\u8272\u4e3a\u7ea2\u6216\u7eff \u8bf7\u95ee\u8fd9X+Y\u4e2a\u82f9\u679c\u7684\u7f8e\u5473\u503c\u6700\u5927\u603b\u548c </p> <p>\u8003\u8651\u6211\u4eec\u5df2\u7ecf\u6709X\u4e2a\u7ea2\u82f9\u679c\uff0cY\u4e2a\u7eff\u82f9\u679c \u663e\u7136\u9009\u62e9\u90a3\u4e9b\u7f8e\u5473\u503c\u5927\u7684 \u518d\u8003\u8651\u67d3\u8272\u65e0\u8272\u82f9\u679c \u5982\u679c\u82f9\u679c\u6570\u8fd8\u4e0d\u591f\uff0c\u5219\u76f4\u63a5\u52a0\u5165 \u5426\u5219\u9700\u8981\u5c06\u5176\u4e0e\u73b0\u6709\u7684\u82f9\u679c\u66ff\u6362,\u663e\u7136\u66ff\u6362\u7f8e\u5473\u503c\u6700\u5c0f\u7684  </p> <pre><code>#include &lt;algorithm&gt;\n#include &lt;bits/stdc++.h&gt;\n#include &lt;functional&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\nusing i64 = long long;\nvoid solve()\n{\n  int X,Y,A,B,C;\n  std::cin&gt;&gt;X&gt;&gt;Y&gt;&gt;A&gt;&gt;B&gt;&gt;C;\n  std::priority_queue&lt;int,std::vector&lt;int&gt;,std::greater&lt;int&gt;&gt;R,G;\n  std::vector&lt;int&gt;W(C);\n\n  for(int i=0;i&lt;A;i++){\n    int x;std::cin&gt;&gt;x;\n    R.emplace(x);\n  }\n  for(int i=0;i&lt;B;i++){\n    int x;std::cin&gt;&gt;x;\n    G.emplace(x);\n  }\n  for (auto &amp;x : W) {\n      std::cin &gt;&gt; x;\n  }\n  while (R.size()&gt;X) {\n    R.pop();\n  }\n  while(G.size()&gt;Y){\n    G.pop();\n  }\n  std::sort(W.begin(),W.end(),std::greater&lt;int&gt;());\n  for(const auto&amp;x:W){\n    if(R.size()&lt;X){\n      R.emplace(x);\n      continue;\n    }\n    else if(G.size()&lt;Y){\n      G.emplace(x);\n      continue;\n    }\n\n    int r=R.top();\n    int g=G.top();\n    if(x&gt;r||x&gt;g){\n      if(r&lt;g){\n        R.pop();\n        R.emplace(x);\n      }\n      else{\n        G.pop();\n        G.emplace(x);\n      }\n    }\n  }\n  i64 ans=0;\n  while(!R.empty()){\n    ans+=R.top();\n    R.pop();\n  }\n  while (!G.empty()) {\n      ans += G.top();\n      G.pop();\n  }\n  std::cout&lt;&lt;ans&lt;&lt;'\\n';\n}\nint main()\n{\n    std::cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    solve();\n}\n</code></pre>"},{"location":"atc/ABC170/","title":"ABC170","text":"<p>E - Smart Infants</p> <p>N\u4e2a\u5b66\u751f\uff0c\u4e00\u5171 2\\times 10^5 \u4e2a\u5b66\u6821 \uff0c\u7b2c i \u4e2a\u5b66\u751f\u7684\u7b49\u7ea7\u4e3a A_i , \u5c5e\u4e8e\u7b2c B_i \u4e2a\u5b66\u6821  </p> <p>\u6709Q\u6b21\u64cd\u4f5c\uff0c\u6bcf\u6b21\u5c06\u5b66\u751fC\u6240\u5c5e\u4e8e\u7684\u5b66\u6821\u6539\u4e3a\u7b2cD\u4e2a\u5b66\u6821  </p> <p>\u64cd\u4f5c\u540e\uff0c\u8f93\u51fa min(\u6bcf\u4e2a\u5b66\u6821\u7684{max{\u5b66\u6821\u5b66\u751f\u7684\u7b49\u7ea7}})</p> <p>\u4e00\u5171\u53ea\u6709 2 \\times 10^5 \u4e2a \u5b66\u6821\uff0c\u4e14\u6bcf\u6b21\u4fee\u6539\u4e3a\u5355\u70b9\u4fee\u6539  </p> <p>\u53ef\u4ee5\u76f4\u63a5\u4fee\u6539\u4e00\u4e2a\u5b66\u6821\u7684\u5b66\u751f\u7684\u6240\u5c5e\uff0c\u4ee5\u53ca\u8fd9\u4e2a\u5b66\u751f\u7684\u8d21\u732e  </p> <p>\u5229\u7528 multiset \u7ef4\u62a4\u6bcf\u4e2a\u5b66\u6821\u7684\u5b66\u751f\u7684\u7b49\u7ea7  </p> <p>\u6211\u4eec\u9700\u8981\u5f97\u5230\u6bcf\u4e2a\u5b66\u6821\u7684\u6700\u5927\u5b66\u751f\u7684\u7b49\u7ea7,\u518d\u6c42min  </p> <p>\u5982\u679c\u66b4\u529b\u505a\uff0c\u663e\u7136\u662f $Q \\times N  \\log{N} $  </p> <p>\u4f7f\u7528 RMQ \u7ef4\u62a4\u6700\u5c0f\u503c\u5373\u53ef  </p> <pre><code>i64 INF=1e10;\nstruct S {\n  i64 x;\n  S(i64 _x=INF):x(_x){}\n};\nS operator+(S l, S r) { return S{std::min(l.x,r.x)}; }\n\nvoid solve()\n{\n    const int M=2e5;\n    int N,Q;\n    std::cin&gt;&gt;N&gt;&gt;Q;\n\n    Segtree&lt;S&gt;seg(M);\n    std::vector&lt;std::multiset&lt;i64&gt;&gt;g(M);\n    std::vector&lt;int&gt;A(N),B(N);\n\n    auto add=[&amp;](int i,int to){\n        auto&amp;v=g[to];\n        v.emplace(A[i]);\n        seg.set(to, S{*v.rbegin()});\n    };\n\n    auto erase=[&amp;](int i,int from){\n        auto&amp;v=g[from];\n        v.erase(v.find(A[i]));\n        if(v.empty()){\n            seg.set(from,S());\n        }\n        else{\n          seg.set(from, S{*v.rbegin()});\n        }\n    };\n\n    for(int i=0;i&lt;N;i++){\n        std::cin&gt;&gt;A[i]&gt;&gt;B[i];\n        --B[i];\n        add(i,B[i]);\n    }\n\n    for(int i=0;i&lt;Q;i++){\n        int C,D;\n        std::cin&gt;&gt;C&gt;&gt;D;\n        --C,--D;\n        erase(C,B[C]);\n        B[C]=D;\n        add(C,B[C]);\n        std::cout&lt;&lt;seg.all_prod().x&lt;&lt;'\\n';\n    }\n}\n</code></pre> <p>\u7531\u4e8e\u662f\u5168\u5c40\u6700\u5c0f,\u5e76\u4e0d\u6d89\u53ca\u533a\u95f4,\u90a3\u4e48\u4f7f\u7528 multiset\u7ef4\u62a4\u662f\u7b49\u4ef7\u7684  </p>"},{"location":"atc/ABC208/","title":"ABC208","text":"<p>E - Digit Products </p> <p>[1,N]\u6709\u591a\u5c11\u4e2a\u6570\u6ee1\u8db3:\u6570\u4f4d\u4e4b\u79ef\\le K,N\\le 10^{18},K\\le 10^{9} </p> <p>\u53ef\u4ee5\u53d1\u73b0\u867d\u7136\u6570\u4f4d\u4e4b\u79ef\u5f88\u5927,\u4f46\u662f\u56e0\u4e3a\u9700\u8981\\le K</p> <p>\u6240\u4ee5\u662f\u79bb\u6563\u7684\u82e5\u5e72\u4e2a\u6570 </p> <p>\u53ef\u4ee5\u901a\u8fc7\u7b80\u5355\u7684\u679a\u4e3e\u77e5\u9053\u8fd9\u6837\u7684\u6570\u4f4d\u4e4b\u79ef\u4e3a5195\u4e2a </p> <p>\u6240\u4ee5\u4f7f\u7528map\u79bb\u6563\u8bb0\u5fc6\u5316 </p> <p>\u5728\u641c\u7d22\u8fc7\u7a0b\u4e2d,\u5982\u679c\u4e00\u76f4\u90fd\u679a\u4e3e\u7684\u662f\u524d\u5bfc0 </p> <p>\u90a3\u4e48\u8fd9\u4e2a\u6570\u7684\u524d\u5bfc0\u4e0d\u80fd\u7b97\u4f5c\u8d21\u732e </p> <p>\u4e5f\u5c31\u662f\u8bf4012=1\\times 2\u7684\u8d21\u732e,\u800c\u4e0d\u662f0\\times 1\\times 2=0 </p> <p>\u4e5f\u5c31\u662f\u8bf4\u524d\u5bfc0\u5f71\u54cd\u7ed3\u679c,\u9700\u8981\u5f00\u4e00\u7ef4\u8fdb\u884c\u8bb0\u5fc6 </p> <p>\u4f7f\u7528map&lt;i64,int&gt;dp[20][2][2]\u8fdb\u884c\u8bb0\u5fc6\u5316 </p> <p>[\u679a\u4e3e\u957f\u5ea6][\u662f\u5426\u8d34\u4e0a\u9650][\u662f\u5426\u6709\u524d\u5bfc0] </p> <pre><code>using i64 = long long;\nstd::map&lt;i64, i64&gt; dp[20][2][2];\ni64 calc(std::string num, i64 K) {\n  int n=(int)num.size();\n  auto dfs=[&amp;](auto self,int i,bool is_limit,bool lead_zero,i64 cur)-&gt;i64{\n    if(i==n){\n      return cur&lt;=K and !lead_zero;\n    }\n    auto&amp;mp=dp[i][is_limit][lead_zero];\n    if(mp.find(cur)!=mp.end()){\n      return mp[cur];\n    }\n    i64 ans=0;\n    int up=is_limit?num[i]-'0':9;\n    for(int d=0;d&lt;=up;d++){\n      if(lead_zero){\n        if(d==0){\n          ans += self(self, i + 1, is_limit &amp;&amp; d == up, true, 0);\n        }\n        else{\n          ans+=self(self,i+1,is_limit &amp;&amp; d==up,false,d);\n        }\n      }\n      else{\n        ans+=self(self,i+1,is_limit &amp;&amp; d==up,false,cur*d);\n      }\n    }\n    return mp[cur]=ans;\n  };\n  return dfs(dfs,0,true,true,1);\n}\nvoid solve() {\n  i64 N, K;\n  std::cin&gt;&gt;N&gt;&gt;K;\n  std::cout&lt;&lt;calc(std::to_string(N), K)&lt;&lt;'\\n';\n}\n</code></pre>"},{"location":"atc/ABC284/","title":"ABC284","text":"<p>F - ABCBAC</p>"},{"location":"atc/ABC284/#_1","title":"\u95ee\u9898","text":"<p>\u5bf9\u4e8e\u957f\u5ea6\u4e3a N \u7684\u5b57\u7b26\u4e32 S \u548c\u6574\u6570 i </p> <p>\u5b9a\u4e49 f_i(S) =  - S \u7684\u524d i \u4e2a \u5b57\u7b26 - S \u53cd\u8f6c\u4e4b\u540e\u7684\u5b57\u7b26\u4e32 - S \u672b\u5c3e\u7684 N-i \u4e2a\u5b57\u7b26  </p> <p>\u6309\u7167\u987a\u5e8f\u8fde\u63a5\u5f97\u5230</p> <p>\u7ed9\u5b9a\u957f\u5ea6\u4e3a 2N \u7684\u5b57\u7b26\u4e32 T \u627e\u5230\u6ee1\u8db3 f_i(S)=T \u7684\u957f\u5ea6\u4e3a N \u7684\u5b57\u7b26\u4e32 S\uff0c\u548c\u6574\u6570 i(0\\leq i \\leq N) </p> <p>\u82e5\u4e0d\u5b58\u5728\uff0c\u8f93\u51fa -1 </p>"},{"location":"atc/ABC284/#1","title":"\u89e3\u6cd51:\u5b57\u7b26\u4e32\u54c8\u5e0c","text":"<p>\u76f4\u63a5\u8003\u8651\u62fc\u63a5\u5b57\u7b26\u4e32</p> <p>\u8003\u8651\u5df2\u7ecf\u5b58\u5728\u8fd9\u6837\u7684\u5b57\u7b26\u4e32 S \u548c\u6574\u6570 i </p> <p>T[0,i)+T[N+i,2N)=rev(T[i,i+N))</p> <p>\u4f7f\u7528\u5b57\u7b26\u4e32\u54c8\u5e0c\u53ef\u4ee5\u505a\u5230 O(1) \u62fc\u63a5</p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing i64 = long long;\n\nusing u64 = uint64_t;\nu64 rng64() {\n  static u64 x =\n      u64(std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(\n              std::chrono::high_resolution_clock::now().time_since_epoch())\n              .count()) *\n      10150724397891781847ULL;\n  x ^= x &lt;&lt; 7;\n  return x ^= x &gt;&gt; 9;\n}\n\ni64 rng(u64 limit) { return rng64() % limit; }\n\ni64 rng(i64 l, i64 r) { return l + rng64() % (r - l); }\n\nusing Z = u64;\n\nconst Z MOD = (1LL &lt;&lt; 61) - 1;\nZ base = Z(rng(3,MOD - 1));\n\nZ safe_mod(Z x) {\n  if (x &gt;= MOD)\n    x -= MOD;\n  return x;\n}\n\nZ mul(Z a, Z b) {\n  Z au = a &gt;&gt; 31;\n  Z ad = a &amp; ((1UL&lt;&lt;31)-1);\n  Z bu = b &gt;&gt; 31;\n  Z bd = b &amp; ((1UL&lt;&lt;31)-1);\n  Z mid = ad * bu + au * bd;\n  Z midu = mid &gt;&gt; 30;\n  Z midd = mid &amp; ((1UL&lt;&lt;30)-1);\n  Z ans = au * bu * 2 + midu + (midd &lt;&lt; 31) + ad * bd;\n  ans = (ans &gt;&gt; 61) + (ans &amp; MOD);\n  return safe_mod(ans);\n}\n\nstruct RollingHash {\n  std::vector&lt;Z&gt; ha, pw;\n  RollingHash(const std::string &amp;s) {\n    int n = s.size();\n    ha.assign(n + 1, Z(0));\n    pw.assign(n + 1, Z(0));\n    pw[0] = 1;\n    for (int i = 0; i &lt; n; i++) {\n      ha[i + 1] = safe_mod(mul(ha[i],base) + s[i]);\n      pw[i + 1] = mul(pw[i],base);\n    }\n  }\n  //[l, r)\n  Z get(int l, int r) const { return safe_mod(ha[r]+MOD - mul(ha[l],pw[r-l])); }\n  Z get() const { return ha.back(); }\n\n  Z merge(Z hl, Z hr, int hr_len) const {\n    return safe_mod(mul(hl,pw[hr_len]) + hr);\n  }\n\n\n  // Lcp of S[a:] and S[b:]\n  int getLcp(int a, int b) const {\n    int len = std::min((int)ha.size() - 1 - a, (int)ha.size() - 1 - b);\n    int lo = 0, hi = len + 1;\n    while (hi - lo &gt; 1) {\n      int mid = (lo + hi) &gt;&gt; 1;\n      if (get(a, a + mid) != get(b, b + mid))\n        hi = mid;\n      else\n        lo = mid;\n    }\n    return lo;\n  }\n\n  // Lcp of S[a:] and T[b:]\n  int getLcp(const RollingHash &amp;T, int a, int b) const {\n    int len = std::min((int)ha.size() - 1 - a, (int)T.ha.size() - 1 - b);\n    int lo = 0, hi = len + 1;\n    while (hi - lo &gt; 1) {\n      int mid = (lo + hi) &gt;&gt; 1;\n      if (get(a, a + mid) != T.get(b, b + mid))\n        hi = mid;\n      else\n        lo = mid;\n    }\n    return lo;\n  }\n};\n\nvoid solve() {\n  int N;\n  std::string s;\n  std::cin &gt;&gt; N &gt;&gt; s;\n\n  RollingHash rhs(s);\n  std::reverse(s.begin(), s.end());\n  RollingHash rhrs(s);\n\n  for (int i = 0; i &lt;= N; i++) {\n    auto x = rhs.get(0, i);\n    auto y = rhs.get(N + i, 2 * N);\n\n    if (rhs.merge(x, y, N - i) == rhrs.get(N - i, 2 * N - i)) {\n      std::cout &lt;&lt; s.substr(N - i, N) &lt;&lt; '\\n' &lt;&lt; i &lt;&lt; '\\n';\n      return;\n    }\n  }\n\n  std::cout &lt;&lt; \"-1\\n\";\n}\nint main() {\n  std::cin.tie(nullptr)-&gt;sync_with_stdio(false);\n  solve();\n}\n</code></pre>"},{"location":"atc/ABC284/#2-z-function","title":"\u89e3\u6cd52: Z function","text":"<p>T = S[0:i] + rev(S) + S[i:N]</p> <p>\u663e\u7136\u6709:</p> <p>T = S[0:i] + rev(S[i:N]) + rev(S[0:i]) + S[i:N]</p> <p>\u8003\u8651\u53cd\u8f6c\u540e\u4e24\u4e2a\u5b57\u7b26\u4e32:  </p> <p>S[0:i]+rev(S[i:N]) + rev(S[i:N]) + S[0:i) </p> <p>\u53d1\u73b0:</p> <p>T[0:i]=rev(T[N,N+i])</p> <p>T[N+i:2N]=rev(T[i:N])</p> <p>\u8bbe A=T[0:N],B=rev(T[N:2N])</p> <p>\u5b58\u5728 i(0\\leq i \\leq N) \u6ee1\u8db3 A[0:i] = B[N-i:N],A[i:N]=B[0:N-i]</p> <p>\u8bbe X=A+B\uff0cY=B+A</p> <p>\u90a3\u4e48\u5b58\u5728 Z(X)[2N-i]=i \\quad Z(Y)[N+i]=N-i</p> <p>\u7b54\u6848\u4e3a: T[0:i]+T[i+N:2N]</p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing i64 = long long;\n\n#include &lt;string&gt;\n#include &lt;vector&gt;\nnamespace internal {\nstd::vector&lt;int&gt; z_func(const std::string &amp;s) {\n  int n = s.size();\n  std::vector&lt;int&gt; z(n);\n  int l = 0, r = 0;\n  for (int i = 1; i &lt; n; i++) {\n    if (i &lt; r) {\n      z[i] = std::min(r - i, z[i - l]);\n    }\n    while (i + z[i] &lt; n &amp;&amp; s[z[i]] == s[i + z[i]]) {\n      z[i]++;\n    }\n    if (i + z[i] &gt; r) {\n      l = i;\n      r = i + z[i];\n    }\n  }\n  return z;\n}\nstd::vector&lt;int&gt; find_occur(const std::string &amp;t, const std::string &amp;p) {\n  std::vector&lt;int&gt; idx;\n  int len_p = p.size(), len_t = t.size();\n  std::string s = p + \"#\" + t;\n  auto z = z_func(s);\n  for (int i = 0; i &lt; len_t; i++) {\n    int k = z[i + len_p + 1];\n    if (k == len_p) {\n      idx.emplace_back(i);\n    }\n  }\n  return idx;\n}\n\nstd::vector&lt;int&gt; prefix_func(const std::string &amp;s) {\n  int n = s.size();\n  std::vector&lt;int&gt; pi(n);\n  for (int i = 1; i &lt; n; i++) {\n    int j = pi[i - 1];\n    while (j &gt; 0 &amp;&amp; s[i] != s[j]) {\n      j = pi[j - 1];\n    }\n    if (s[i] == s[j]) {\n      j++;\n    }\n    pi[i] = j;\n  }\n  return pi;\n}\n\nbool match(const std::string &amp;t, const std::string &amp;p) {\n  auto lps = prefix_func(p + \"#\" + t);\n  int sz1 = t.size(), sz2 = p.size();\n  for (int i = sz2 + 1; i &lt;= sz1 + sz2; i++) {\n    if (lps[i] == sz2) {\n      return true;\n    }\n  }\n  return false;\n}\n} // namespace internal\n\nvoid solve()\n{\n  int n;std::string t;\n  std::cin&gt;&gt;n&gt;&gt;t;\n\n  std::string a=t.substr(0,n);\n  std::string b=t.substr(n);\n  std::reverse(b.begin(),b.end());\n\n  std::string x=a+b,y=b+a;\n  auto zx=internal::z_func(x);\n  auto zy=internal::z_func(y);\n  zx.push_back(0);\n  zy.push_back(0);\n\n  for(int i=0;i&lt;=n;i++){\n    if(zx[2*n-i]&lt;i)continue;\n    if(zy[n+i]&lt;n-i)continue;\n    std::cout&lt;&lt;t.substr(0,i)+t.substr(n+i)&lt;&lt;'\\n';\n    std::cout&lt;&lt;i&lt;&lt;'\\n';\n    return;\n  }\n  std::cout&lt;&lt;\"-1\\n\";\n}\nint main()\n{\n    std::cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    solve();\n}\n</code></pre>"},{"location":"atc/ABC325/","title":"ABC325","text":"<p>E - Our clients, please wait a moment</p> <p>\u6709N\u57ce\u5e02\uff0c\u8981\u4ece1\u8d70\u5230N \u7ed9\u5b9a\u4e00\u4e2a\u90bb\u63a5\u77e9\u9635\u4f5c\u4e3a\u52a0\u6743 \u6709\u4e24\u79cd\u4ea4\u901a\u65b9\u5f0f  </p> <ul> <li>\u6c7d\u8f66:D_{i,j}*A</li> <li>\u706b\u8f66:D_{i,j}*B+C</li> </ul> <p>\u53ef\u4ee5\u4ece\u6c7d\u8f66\u6362\u706b\u8f66\uff0c\u4e0d\u80fd\u4ece\u706b\u8f66\u6362\u6c7d\u8f66 \u95ee\u4ece\u57ce\u5e021\u8d70\u5230N\u6700\u77ed\u9700\u8981\u591a\u5c11\u5206\u949f</p> <p>\u9884\u5904\u7406\u6c7d\u8f661-i\u7684\u6700\u77ed\u8def\uff0c\u706b\u8f66i-N\u7684\u6700\u77ed\u8def  \u6700\u540e\u679a\u4e3e\u4e2d\u8f6c\u7684\u57ce\u5e02\u5373\u53ef</p> <pre><code>#include &lt;bits/stdc++.h&gt;\n#include &lt;limits&gt;\n#include &lt;vector&gt;\nusing i64 = long long;\n\ntemplate &lt;typename T&gt; struct Dijkstra {\n    struct Edge {\n        int to;\n        T cost;\n        Edge(int _to, T _cost) : to(_to), cost(_cost) {}\n        bool operator&lt;(const Edge &amp;o) const { return cost &gt; o.cost; }\n    };\n    std::vector&lt;std::vector&lt;Edge&gt;&gt; G;\n    std::vector&lt;T&gt; ds;\n    std::vector&lt;int&gt; bs;\n    Dijkstra(int n) : G(n) {}\n\n    void add_edge(int u, int v, T c) { G[u].emplace_back(v, c); }\n    void build(int s) {\n        int n = G.size();\n        ds.assign(n, std::numeric_limits&lt;T&gt;::max());\n        bs.assign(n, -1);\n        std::priority_queue&lt;Edge&gt; pq;\n        ds[s] = 0;\n        pq.emplace(s, ds[s]);\n        while (not pq.empty()) {\n            auto [u, cost_u] = pq.top();\n            pq.pop();\n            if (ds[u] &lt; cost_u) {\n                continue;\n            }\n            for (auto [v, cost_v] : G[u]) {\n                if (ds[v] &gt; ds[u] + cost_v) {\n                    ds[v] = ds[u] + cost_v;\n                    bs[v] = u;\n                    pq.emplace(v, ds[v]);\n                }\n            }\n        }\n    }\n\n    T operator[](int k) { return ds[k]; }\n    std::vector&lt;int&gt; restore(int to) {\n        std::vector&lt;int&gt; ans;\n        if (bs[to] &lt; 0) {\n            return ans;\n        }\n        while (~to) {\n            ans.emplace_back(to);\n            to = bs[to];\n        }\n        std::reverse(ans.begin(), ans.end());\n        return ans;\n    }\n};\n\nvoid solve()\n{\n  int N,A,B,C;\n  std::cin&gt;&gt;N&gt;&gt;A&gt;&gt;B&gt;&gt;C;\n  std::vector&lt;std::vector&lt;i64&gt;&gt;D(N,std::vector&lt;i64&gt;(N));\n  for(int i=0;i&lt;N;i++){\n    for(int j=0;j&lt;N;j++){\n      std::cin&gt;&gt;D[i][j];\n    }\n  }\n  Dijkstra&lt;i64&gt;g(N),rg(N);\n  for(int i=0;i&lt;N;i++){\n    for(int j=0;j&lt;N;j++){\n      if(!D[i][j])continue;\n      g.add_edge(i, j, D[i][j]*A);\n      rg.add_edge(i, j, D[i][j]*B+C);\n    }\n  }\n  int s=0,t=N-1;\n  g.build(s);\n  rg.build(t);\n  i64 ans=std::numeric_limits&lt;i64&gt;::max();\n  for(int i=0;i&lt;N;i++){\n    ans=std::min(ans,g[i]+rg[i]);\n  }\n  std::cout&lt;&lt;ans&lt;&lt;'\\n';\n}\nint main()\n{\n    std::cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    solve();\n}\n</code></pre>"},{"location":"atc/ABC349/","title":"ABC349","text":"<p>A - Zero Sum Game</p> <p>N\u4e2a\u4eba\u521d\u59cb0\u5206\uff0c\u76f8\u4e92\u8fdb\u884c1\u5bf91\u6bd4\u8d5b\uff0c\u80dc\u8005+1\u5206\uff0c\u8d25\u8005-1\u5206  </p> <p>\u5df2\u77e5\u6700\u7ec8 [1,n) \u7684\u4eba\u7684\u5206\u6570  </p> <p>\u6c42\u7b2cn\u4e2a\u4eba\u7684\u5206\u6570 </p> <p>\u7531\u4e8e\u80dc\u8005+1,\u8d25\u8005-1,\u90a3\u4e48\u603b\u7684\u5206\u6570\u548c\u59cb\u7ec8\u4e3a0  </p> <p>\u7b54\u6848\u5373\u4e3a - \\sum_{1}^{n-1} a_i </p> <pre><code>void solve()\n{\n    int n;std::cin&gt;&gt;n;\n    i64 ans=0;\n    for(int i=1;i&lt;n;i++){\n        int x;std::cin&gt;&gt;x;\n        ans+=x;\n    }\n    std::cout&lt;&lt;-ans&lt;&lt;'\\n';\n}\n</code></pre> <p>B - Commencement</p> <p>\u7ed9\u5b9a\u5b57\u7b26\u4e32S\uff0c\u8bbe\u5176\u957f\u5ea6\u4e3aN  </p> <p>\u82e5 \u5bf9\u4e8e i\\in[1,N],S\u4e2d\u6070\u67090\u79cd\u62162\u79cd\u5b57\u7b26\u51fa\u73b0i\u6b21 </p> <p>\u79f0\u5176\u4e3a\"\u597d\u5b57\u7b26\u4e32\"  </p> <p>\u5224\u65adS\u662f\u5426\u662f\u597d\u5b57\u7b26\u4e32 </p> <p>\u6309\u7167\u9898\u610f\u6a21\u62df\u5373\u53ef  </p> <pre><code>void solve()\n{\n    std::string s;std::cin&gt;&gt;s;\n    std::vector&lt;int&gt;cnt(26);\n    for(auto ch:s){\n        int x=ch-'a';\n        cnt[x]++;\n    }\n    auto check = [&amp;]()\n    {\n        for (int i = 1; i &lt;= (int)s.size(); i++)\n        {\n            int res=0;\n            for(auto x:cnt){\n                res+=x==i;\n            }           \n            if(res==0||res==2){\n            }\n            else{\n                return false;\n            }\n        }\n        return true;\n    };\n\n    std::cout&lt;&lt;(check()?\"Yes\":\"No\")&lt;&lt;'\\n';\n}\n</code></pre> <p>C - Airport Code</p> <p>\u7ed9\u5b9a\u5b57\u7b26\u4e32S\uff0cT T \u7531 S \u64cd\u4f5c\u5f97\u6765  </p> <ul> <li>\u53d6S\u4e2d\u957f\u5ea6\u4e3a3\u7684\u5b50\u5e8f\u5217\uff0c\u518d\u8f6c\u4e3a\u5927\u5199\u5b57\u6bcd </li> <li>\u53d6S\u4e2d\u957f\u5ea6\u4e3a2\u7684\u5b50\u5e8f\u5217\uff0c\u518d\u8f6c\u4e3a\u5927\u5199\u5b57\u6bcd\uff0c\u5e76\u9644\u52a0\u5b57\u7b26'X'  </li> </ul> <p>\u95eeT\u662f\u5426\u7531S\u64cd\u4f5c\u5f97\u6765</p> <p>\u7531\u4e8eT\u5f88\u5c0f\uff0c\u4e8c\u5206\u627e3 or 2\u6b21\u662f\u5426\u5b58\u5728\u8fd9\u4e9b\u5b50\u5e8f\u5217\u5373\u53ef  </p> <pre><code>void solve()\n{\n    std::string s,t;\n    std::cin&gt;&gt;s&gt;&gt;t;\n\n    std::map&lt;char,std::vector&lt;int&gt;&gt;id;\n\n    for(int i=0;i&lt;(int)s.size();i++){\n        id[s[i]].emplace_back(i);\n    }\n\n    auto op = [&amp;](bool flag)\n    {\n        const std::vector&lt;int&gt; &amp;v1 = id[std::tolower(t[0])];\n        const std::vector&lt;int&gt; &amp;v2 = id[std::tolower(t[1])];\n        const std::vector&lt;int&gt; &amp;v3 = id[std::tolower(t[2])];\n\n        if(v1.empty()){\n            return false;\n        }\n        int i1=v1.front();\n        auto it=std::upper_bound(v2.begin(),v2.end(),i1);\n        if(it==v2.end())\n        {\n            return false;\n        }\n        if(flag)\n        {\n            return true;\n        }\n        auto i2=*it;\n        it=std::upper_bound(v3.begin(),v3.end(),i2);\n        if(it==v3.end())\n        {\n            return false;\n        }\n        return true;\n    };\n    if(t.back()=='X'){\n        std::cout&lt;&lt;(op(true)?\"Yes\":\"No\")&lt;&lt;'\\n';\n    }\n    else{\n        std::cout&lt;&lt;(op(false)?\"Yes\":\"No\")&lt;&lt;'\\n';\n    }\n}\n</code></pre> <p>D - Divide Interval</p> <p>\u7ed9\u5b9aL\uff0cR\uff0c\u5c06\u533a\u95f4 [L,R) \u5212\u5206\u4e3a  </p> <p>\u7c7b\u4f3c\u4e8e [2^{i}j,2^{i}(j+1)) \u7684\u533a\u95f4</p> <p>\u95ee\u6700\u5c0f\u5212\u5206\u65b9\u6848</p> <p>\u6839\u636e\u6837\u4f8b</p> <pre><code>3 19\n\n5\n3 4\n4 8\n8 16\n16 18\n18 19\n\n(11) (100)  +1\n(100) (1000) +4\n(1000) (10000) +8\n(10000) (10010) +2\n(10010) (10011) +1\n\n</code></pre> <p>\u518d\u6839\u636e 2^{i}j,2^{i}(j+1) </p> <p>\u53d1\u73b0\u4e00\u6b21\u7684\u589e\u91cf\u4e3a  2^{i}</p> <p>\u540c\u65f6  $i\\ge 1 \u65f6\uff0c\u6709: $</p> <p>2^{i}=2*2^{i-1} </p> <p>2^{i}*j=2^{i-1}(2j) \\rightarrow 2^{i-1}(2j+1)</p> <p>\u4e5f\u5373\u589e\u91cf\u4e3a 2^{i-1} </p> <p>\u4e5f\u5c31\u662f\u8bf4\u6bcf\u6b21\u6211\u4eec\u627e\u5230\u8fd9\u4e2a\u6570\u5b57\u7684\u4e8c\u8fdb\u5236\u6700\u53f3\u8fb9\u76841\uff0c\u8d2a\u5fc3\u5730\u53bb\u6dfb\u52a0\u589e\u91cf\uff0c\u4fdd\u8bc1 x+2^{i}\\le R</p> <p>\u5bf9\u4e8e0\u6765\u8bf4\uff0c\u76f4\u63a5\u6dfb\u52a0R\u7684\u6700\u5de6\u8fb9\u76841\u5373\u53ef\u8f6c\u4e3a\u4e00\u822c\u60c5\u51b5  </p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing i64 = long long;\n\ni64 first_one(i64 x)\n{\n    for (i64 i = 0; i &lt; 63; i++)\n    {\n        if (x &gt;&gt; i &amp; 1)\n        {\n            return i;\n        }\n    }\n}\ni64 last_one(i64 x)\n{\n    return 63 - __builtin_clzll(x);\n}\nvoid solve()\n{\n    i64 L, R;\n    std::cin &gt;&gt; L &gt;&gt; R;\n\n    i64 ir = last_one(R);\n\n    auto op = [&amp;](i64 x)\n    {\n        i64 ix = first_one(x);\n\n        for (i64 i = ix; i &gt;= 0; i--)\n        {\n            i64 y = 1LL &lt;&lt; i;\n            if (x + y &lt;= R)\n            {\n                return x + y;\n            }\n        }\n    };\n\n    std::vector&lt;std::pair&lt;i64, i64&gt;&gt; ans;\n    if (L == 0)\n    {\n        ans.emplace_back(L, 1LL &lt;&lt; ir);\n        L = 1LL &lt;&lt; ir;\n    }\n    while (L &lt; R)\n    {\n        i64 x = op(L);\n        ans.emplace_back(L, x);\n        L = x;\n    }\n    std::cout &lt;&lt; ans.size() &lt;&lt; '\\n';\n    for (const auto &amp;[l, r] : ans)\n    {\n        std::cout &lt;&lt; l &lt;&lt; ' ' &lt;&lt; r &lt;&lt; '\\n';\n    }\n}\nint main()\n{\n    std::cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    solve();\n    return 0;\n}\n\n</code></pre>"},{"location":"cf/CF560/","title":"CF560","text":"<p>E. Two Arrays and Sum of Functions</p> <p>N \u957f\u5ea6\u7684\u6570\u7ec4 a,b </p> <p>f(l,r)=\\sum_{l\\le i \\le r}a_i \\times b_i </p> <p>\u53ef\u4ee5\u4efb\u610f\u6392\u5e8f b \u6570\u7ec4</p> <p>min:\\sum_{1\\le l \\le r\\le n}f(l,r) </p> <p>\u5148\u8003\u8651 a_i\\times b_i \u7684\u51fa\u73b0\u6b21\u6570  </p> <p>1\\le l \\le i \u7684l\u4e00\u5171\u6709 i \u4e2a\uff0ci\\le r \\le n\u7684r\u4e00\u5171\u6709(n-i+1)\u4e2a</p> <p>\u6240\u4ee5\u4e00\u5171\u5305\u542b i \u7684\u533a\u95f4\u7684\u4e2a\u6570\u4e3a i\\times (n-i+1) </p> <p>\u6545 a_i\\times b_i \u7684\u8d21\u732e \u4e3a a_i\\times b_i\\times i\\times (n-i+1) </p> <p>\u8bb0\u5728 i \u5904\u7684\u4e0d\u53d8\u91cf\u4e3ac_i=a_i\\times i\\times(n-i+1)</p> <p>\u603b\u7684\u8d21\u732e\u4e3a:\\sum_{1\\le i \\le n}b_i\\times c_i </p> <p>\u8d2a\u5fc3\u5373\u53ef\uff0c\u964d\u5e8f\u6392\u5e8fc\uff0c\u5347\u5e8f\u6392\u5e8fb </p> <pre><code>using Z=Mint&lt;int,998244353&gt;;\nvoid solve() {\n    int N;std::cin&gt;&gt;N;\n    std::vector&lt;i64&gt;a(N+1),b(N+1);\n    for(int i=1;i&lt;=N;i++){\n        std::cin&gt;&gt;a[i];\n    }\n    for(int i=1;i&lt;=N;i++){\n        std::cin&gt;&gt;b[i];\n    }\n    std::vector&lt;i64&gt;c(N+1);\n    for(int i=1;i&lt;=N;i++){\n        c[i]=1LL*a[i]*i*(N-i+1);\n    }\n    std::sort(c.begin()+1,c.end(),std::greater&lt;i64&gt;());\n    std::sort(b.begin()+1,b.end());\n    Z ans=0;\n    for(int i=1;i&lt;=N;i++){\n        ans+=Z(c[i])*Z(b[i]);\n    }\n    std::cout&lt;&lt;ans&lt;&lt;'\\n';\n}\n</code></pre>"},{"location":"dp/bit_dp/","title":"bit dp","text":"<p>D - \u5f92\u7af6\u8d70</p> <p>N \u5154\u5b50\u7ade\u8d70\uff0c\u4e00\u5171\u6709 N! \u79cd\u6bd4\u8d5b\u7ed3\u679c  (N\\le 16) </p> <p>M \u5bf9\u5173\u7cfb\uff0c\u63cf\u8ff0 \u5154\u5b50 x \u5148\u4e8e \u5154\u5b50 y \u5b8c\u6210\u6bd4\u8d5b  </p> <p>\u6c42\u6709\u591a\u5c11\u79cd\u7b26\u5408M\u5bf9\u5173\u7cfb\u7684\u6bd4\u8d5b\u7ed3\u679c  </p>  f(S)= \\begin{cases}     1 \\quad (S=\\emptyset)\\\\     \\sum_{v\\in X_S}f(S-\\{v\\}) \\quad (otherwise) \\end{cases}  <p>\u7531\u9898\u76ee\u53ef\u77e5\uff0c\u6709\u5411\u8fb9 u \\rightarrow v \u6210\u7acb  </p> <p>\u53cd\u4e4b v \\rightarrow u \u4e0d\u6210\u7acb  </p> <p>\u68c0\u67e5\u4e0d\u6210\u7acb\u7684\u8fb9  </p> <p>\u521d\u59cb\u5316: dp[0]=1 </p> <p>\u5411\u96c6\u5408 S \u6dfb\u52a0\u65b0\u7684\u9876\u70b9  v  ,\u4fdd\u8bc1 v \u4e0d\u5728\u96c6\u5408 S \u91cc  </p> <p>\u679a\u4e3e\u96c6\u5408\u5df2\u6709\u7684\u9876\u70b9 u , \u7531\u4e8e u \u51fa\u73b0\u4e8e v \u4e4b\u524d  </p> <p>\u90a3\u4e48\uff0c\u6709\u5411\u8fb9 v \\rightarrow u \u4e0d\u6210\u7acb  </p> <pre><code>using i64 = long long;\nvoid solve()\n{\n    int N,M;std::cin&gt;&gt;N&gt;&gt;M;\n    std::vector g(N,std::vector&lt;bool&gt;(N,false));\n    for(int i=0;i&lt;M;i++){\n        int u,v;\n        std::cin&gt;&gt;u&gt;&gt;v;\n        --u,--v;\n        g[v][u]=true;\n    }\n    std::vector&lt;i64&gt;dp(1&lt;&lt;N);\n    dp[0]=1;\n    for(int S=0;S&lt;(1&lt;&lt;N);S++){\n        for(int v=0;v&lt;N;v++){\n            if(!(S&gt;&gt;v&amp;1)){\n                bool ok=true;\n                for(int u=0;u&lt;N;u++){\n                    if(S&gt;&gt;u&amp;1){\n                        if(g[v][u])ok=false;\n                    }\n                }\n                if(ok)dp[S+(1&lt;&lt;v)]+=dp[S];\n            }\n        }\n    }\n    std::cout&lt;&lt;dp[(1&lt;&lt;N)-1]&lt;&lt;'\\n';\n}\n\n</code></pre> <p>E - Traveling Salesman among Aerial Cities</p> <p>\u6709 N \u57ce\u5e02\uff0c(N\\le 17) , \u7f16\u53f7\u4e3a 1-N \uff0c\u57ce\u5e02 i \u4f4d\u4e8e\u5750\u6807 (X_i,Y_i,Z_i) </p> <p>\u4ece (a,b,c) \u5230 (p,q,r) \u7684\u82b1\u8d39\u4e3a  |p-a|+|q-b|+max(0,r-c) </p> <p>\u6c42\u4ece\u57ce\u5e021\u51fa\u53d1\uff0c\u8bbf\u95ee\u6bcf\u4e2a\u57ce\u5e02\u81f3\u5c111\u6b21\uff0c\u7136\u540e\u8fd4\u56de\u57ce\u5e021\u7684\u6700\u5c0f\u82b1\u8d39 </p> <p>\u9996\u5148\u9884\u5904\u7406\u6bcf\u4e2a\u57ce\u5e02\u4e4b\u95f4\u7684\u82b1\u8d39,\u8bb0\u4e3a g </p> <p>\u6bcf\u4e2a\u57ce\u5e02\u90fd\u8981\u81f3\u5c11\u8bbf\u95ee\u4e00\u6b21 </p> <ul> <li>1 \u8bbf\u95ee\u81f3\u5c111\u6b21  </li> <li>0 \u8bbf\u95ee0\u6b21  </li> </ul> <p>dp[S][u]:\u9876\u70b9\u96c6\u5408S\uff0c\u4ee5u\u7ed3\u5c3e\u7684\u8def\u5f84\u6700\u5c0f\u82b1\u8d39</p> <p>\u6700\u7ec8\u72b6\u6001\u4e3a (1&lt;&lt;N)-1 \\quad ,N \u4f4d\u5168\u4e3a1  </p> <p>\u521d\u59cb\u5316  dp[0][0]=0,dp[1&lt;&lt;i][i]=g[0][i] </p> <p>\u5411\u96c6\u5408 S \u6dfb\u52a0\u9876\u70b9 v  \uff0c\u4fdd\u8bc1 S \u4e2d\u6ca1\u6709\u9876\u70b9 v </p> <p>\u679a\u4e3e\u5df2\u6709\u9876\u70b9  u ,\u4fdd\u8bc1 S \u4e2d\u5b58\u5728\u9876\u70b9 u </p> <p>\u66f4\u65b0\u6700\u5c0f\u503c chmin(dp[S|1&lt;&lt;v][v],dp[S][u]+g[u][v]) </p> <pre><code>using i64 = long long;\nusing T=std::tuple&lt;int,int,int&gt;;\ni64 calc(const T&amp;l,const T&amp;r){\n    const auto&amp;[lx,ly,lz]=l;\n    const auto&amp;[rx,ry,rz]=r;\n    return std::abs(lx-rx)+std::abs(ly-ry)+std::max(0,rz-lz);\n}\nvoid chmin(i64&amp;x,i64 y){\n    x=std::min(x,y);\n}\nvoid solve()\n{\n    int N;std::cin&gt;&gt;N;\n    std::vector&lt;T&gt;a(N);\n    for(auto&amp;[x,y,z]:a){\n        std::cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;\n    }\n    std::vector g(N,std::vector&lt;i64&gt;(N));\n    for(int i=0;i&lt;N;i++){\n        for(int j=0;j&lt;N;j++){\n            if(i==j)continue;\n            g[i][j]=calc(a[i],a[j]);\n        }\n    }\n    const i64 NIL=-1;\n    const i64 INF=1e9;\n    std::vector dp(1&lt;&lt;N,std::vector(N,INF));\n    dp[0][0]=0;\n    for(int i=1;i&lt;N;i++){\n        dp[1&lt;&lt;i][i]=g[0][i];\n    }\n    for(int S=0;S&lt;(1&lt;&lt;N);S++){\n        for(int u=0;u&lt;N;u++){\n            if(~S&gt;&gt;u&amp;1)continue;\n            for(int v=0;v&lt;N;v++){\n                if(S&gt;&gt;v&amp;1)continue;\n                chmin(dp[S|1&lt;&lt;v][v],dp[S][u]+g[u][v]);\n            }\n        }\n    }\n\n    std::cout&lt;&lt;dp[(1&lt;&lt;N)-1][0]&lt;&lt;'\\n';\n}\n\n</code></pre> <p>E - Get Everything </p> <p>N \u4e2a\u5b9d\u7bb1\uff0c\u7f16\u53f7 1-N \\quad N\\le 12 </p> <p>\u5171\u6709 M \u4e2a\u94a5\u5319  </p> <p>\u7b2c i \u628a\u94a5\u5319\u552e\u4ef7\u4e3a a_i  ,\u53ef\u4ee5\u6253\u5f00 b_i \u4e2a\u5b9d\u7bb1  </p> <p>\u8bf7\u95ee\u6253\u5f00\u6240\u6709\u5b9d\u7bb1\u7684\u6700\u5c0f\u8d39\u7528\uff0c\u82e5\u65e0\u6cd5\u6253\u5f00\u6240\u6709\u5b9d\u7bb1\uff0c\u8f93\u51fa-1 </p> <p>\u6bcf\u4e2a\u5b9d\u7bb1\u90fd\u8981\u6253\u5f00\uff0c\u90a3\u4e48\u6700\u7ec8\u6001\u4e3a (1&lt;&lt;N)-1 </p> <p>dp[S][i]:\u5b9d\u7bb1\u96c6\u5408S\uff0c\u679a\u4e3e\u5230\u7b2c i\u628a\u94a5\u5319 </p> <p>\u7531\u4e8e\u4e00\u628a\u94a5\u5319\u53ef\u4ee5\u5f00 b_i \u4e2a\u5b9d\u7bb1\uff0c\u4e14\u4e0d\u9650\u4f7f\u7528  \uff0c\u90a3\u4e48\u4e00\u628a\u94a5\u5319\u5bf9\u5e94\u4e00\u4e2a\u5b9d\u7bb1\u72b6\u6001\uff0c\u8bb0\u4e3a c_i </p> <p>\u521d\u59cb\u5316: dp[0][0]=0 </p> <p>\u4e0d\u4f7f\u7528\u94a5\u5319 i chmin(dp[S][i+1],dp[S][i]) </p> <p>\u4f7f\u7528\u94a5\u5319 i chmin(dp[S|c_i][i+1],dp[S][i]+a_i) </p> <pre><code>using i64 = long long;\nvoid chmin(int&amp;x,int y){\n    x=std::min(x,y);\n}\nvoid solve()\n{\n    int N,M;std::cin&gt;&gt;N&gt;&gt;M;\n    std::vector&lt;int&gt;a(M),c(M);\n    for(int i=0;i&lt;M;i++){\n        int b;\n        std::cin&gt;&gt;a[i]&gt;&gt;b;\n        for(int j=0;j&lt;b;j++){\n            int x;std::cin&gt;&gt;x;\n            --x;\n            c[i]|=1&lt;&lt;x;\n        }\n    }\n    const int INF=1e9;\n    std::vector dp(1&lt;&lt;N,std::vector&lt;int&gt;(M+1,INF));\n    dp[0][0]=0;\n    for(int i=0;i&lt;M;i++){\n        for(int S=0;S&lt;(1&lt;&lt;N);S++){\n            chmin(dp[S][i+1],dp[S][i]);\n            chmin(dp[S|c[i]][i+1],dp[S][i]+a[i]);\n        }\n    }\n    std::cout&lt;&lt;(dp[(1&lt;&lt;N)-1][M]==INF?-1:dp[(1&lt;&lt;N)-1][M])&lt;&lt;'\\n';\n}\n</code></pre>"},{"location":"dp/dp_on_digits/","title":"dp on digits","text":"<p>\u6570\u4f4ddp\u7684dfs\u6a21\u677f</p> <pre><code>template&lt;typename T&gt;\nT calc(std::string num){\n    //calc on num\n    int n=num.size();\n    // for not visit\n    const T NIL=-1;\n    //n,is_limit,...(other condition)\n    std::vector dp(n,std::vector(2,NIL));\n\n\n    // after limit,follow some condition\n    auto dfs=[&amp;](auto self,int i,bool is_limit)-&gt;T{\n        // the end of dfs\n        if(i==n){\n            //return condition\n        }\n        auto&amp;res=dp[i][is_limit];//[condition]\n\n        // had calc\n        if(res!=NIL){\n            return res;\n        }\n\n        T ans=0;\n        int up=is_limit?s[i]-'0':'9';\n        // enumerate digit\n        for(int d=0;d&lt;=up;d++){\n            //next dfs\n            ans+=self(self,i+1,is_limit and d==up);\n        }\n        return res=ans;\n    };  \n    return dfs(dfs,0,true);\n}\n\n</code></pre> <p>D - \u7981\u6b62\u3055\u308c\u305f\u6570\u5b57</p> <pre><code>\nusing i64 = long long;\n\ni64 calc(std::string&amp;&amp; s){\n  int n=s.size();\n  const i64 NIL=-1;\n\n  std::vector dp(n,std::vector(2,std::vector(2,NIL)));\n\n  auto dfs=[&amp;](auto self,int i,bool is_limit,bool forbid)-&gt;i64{\n    if(i==n){\n      return forbid;\n    }\n    auto&amp;res=dp[i][is_limit][forbid];\n    if(res!=NIL){\n      return res;\n    }\n    i64 ans=0;\n    int up=is_limit?s[i]-'0':9;\n    for(int d=0;d&lt;=up;d++){\n      ans+=self(self,i+1,is_limit and d==up,forbid or d==4 or d==9);\n    }\n    return res=ans;\n  };\n  return dfs(dfs, 0, true, false);\n}\n\nvoid solve()\n{\n  i64 A,B;std::cin&gt;&gt;A&gt;&gt;B;\n  std::cout &lt;&lt; calc(std::to_string(B)) - calc(std::to_string(A - 1)) &lt;&lt; '\\n';\n}\n</code></pre> <p>E - Almost Everywhere Zero</p> <p>1-N \u4e4b\u95f4\uff0c\u6070\u6709K\u4e2a\u975e\u96f6\u6570\u4f4d\u7684\u6570\u6709\u591a\u5c11\u4e2a</p> <pre><code>using i64 = long long;\nvoid solve()\n{\n  std::string S;int K;std::cin&gt;&gt;S&gt;&gt;K;\n\n  int n=S.size();\n  const i64 NIL=-1;\n  std::vector dp(n,std::vector(2,std::vector(K+1,NIL)));\n\n  auto dfs=[&amp;](auto self,int i,bool is_limit,int cnt)-&gt;i64{\n    if(i==n){\n      return cnt==K;\n    }\n    auto&amp;res=dp[i][is_limit][cnt];\n    if(res!=NIL)return res;\n    i64 ans=0;\n    int up=is_limit?S[i]-'0':9;\n    for(int d=0;d&lt;=up;d++){\n      if(d){\n        if(cnt&lt;K)ans+=self(self,i+1,is_limit and d==up,cnt+1);\n      }\n      else{\n        ans+=self(self,i+1,is_limit and d==up,cnt);\n      }\n    }\n    return res=ans;\n  };\n\n  std::cout&lt;&lt;dfs(dfs,0,true,0)&lt;&lt;'\\n';\n\n}\n</code></pre>"},{"location":"dp/dp_on_tree/","title":"dp on  tree","text":"<p>DP on Trees Tutorial</p>"},{"location":"dp/dp_on_tree/#problem-1","title":"Problem 1","text":"<p>N\u4e2a\u70b9\u7684\u6811\uff0c\u6bcf\u4e2a\u8282\u70b9 i \u6709\u6743\u503c C_i </p> <p>\u4f60\u53ef\u4ee5\u9009\u62e9\u4e00\u4e9b\u8282\u70b9 \uff0c\u5e76\u4fdd\u6301\u8282\u70b9\u4e24\u4e24\u4e0d\u76f8\u90bb\uff0c\u8ba1\u7b97\u5176\u603b\u548c, \u6c42\u51fa\u6700\u5927\u603b\u548c    </p> <p>max:{ \\sum c_i }</p> <p>\u8bbe\u5f53\u524d\u8282\u70b9\u4e3a u , u \u7684\u7236\u4eb2\u4e3a f,u\u76f8\u90bb\u7684\u8282\u70b9\u4e3av  </p> <ul> <li> <p>\u82e5\u9009\u62e9 u , \u90a3\u4e48\u4e0d\u80fd\u9009\u62e9 v ,\u53ea\u80fd\u9009\u62e9v\u7684\u513f\u5b50  </p> </li> <li> <p>\u82e5\u4e0d\u9009\u62e9 u , \u90a3\u4e48\u53ef\u4ee5\u9009\u62e9v,\u4e5f\u53ef\u4ee5\u9009\u62e9v\u7684\u513f\u5b50  </p> </li> </ul> <p>\u8bbe dp[u][0]: \u4e0d\u9009\u62e9 u\u8282\u70b9  ,dp[u][1]:\u9009\u62e9u\u8282\u70b9  </p> <pre><code>dp[u][0]+= std::max(dp[v][0],dp[v][1])  \n\ndp[u][1]+= C[u]+ dp[v][0]  \n\n</code></pre> <pre><code>//adjacency list\n//adj[i] contains all neighbors of i\nvector&lt;int&gt; adj[N];\n\n//functions as defined above\nint dp1[N],dp2[N];\n\n//pV is parent of node V\nvoid dfs(int V, int pV){\n\n    //for storing sums of dp1 and max(dp1, dp2) for all children of V\n    int sum1=0, sum2=0;\n\n    //traverse over all children\n    for(auto v: adj[V]){\n    if(v == pV) continue;\n    dfs(v, V);\n    sum1 += dp2[v];\n    sum2 += max(dp1[v], dp2[v]);\n    }\n\n    dp1[V] = C[V] + sum1;\n    dp2[V] = sum2;\n}\n\nint main(){\n    int n;\n    cin &gt;&gt; n;\n\n    for(int i=1; i&lt;n; i++){\n    cin &gt;&gt; u &gt;&gt; v;\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n    }\n\n    dfs(1, 0);\n    int ans = max(dp1[1], dp2[1]);\n    cout &lt;&lt; ans &lt;&lt; endl;\n}\n\n</code></pre>"},{"location":"dp/dp_on_tree/#problem-2","title":"Problem 2","text":"<p>N\u4e2a\u70b9\u7684\u6811\uff0c\u8ba1\u7b97\u4efb\u610f\u4e24\u4e2a\u8282\u70b9\u4e4b\u95f4\u7684\u6700\u957f\u8def\u5f84  </p> <p>\u8bbe\u6839\u8282\u70b9\u4e3a root=1  </p> <ul> <li>f(x) : \u6700\u957f\u8def\u5f84\u4ece\u8282\u70b9x\u5f00\u59cb\u5e76\u7ec8\u6b62\u4e8ex\u7684\u5b50\u6811\u8282\u70b9  </li> <li>g(x) : \u6700\u957f\u8def\u5f84\u4ece\u8282\u70b9x\u7684\u5b50\u6811\u8282\u70b9\u5f00\u59cb\uff0c\u7ecf\u8fc7x\uff0c\u7ec8\u6b62\u4e8ex\u7684\u5b50\u6811\u8282\u70b9  </li> </ul> <p>\u7b54\u6848\u4e3a: </p> <p>x \\in V, max\\{  f(x),g(x) \\} </p> <p>if x is leaf,then f[x]=0</p> <p>f(x)=1+max \\{f(y)\\}\\quad y\u662fx\u7684\u513f\u5b50 </p> <p>g(x)=2+sum \\ of \\ two \\  max \\ \\{ f(y) \\}\\quad y\u662fx\u7684\u513f\u5b50</p> <p>\u6a21\u677f\u9898: Tree Diameter</p> <pre><code>void solve()\n{\n  int n;std::cin&gt;&gt;n;\n  std::vector&lt;std::vector&lt;int&gt;&gt;adj(n);\n\n  for(int i=1;i&lt;n;i++){\n    int u,v;std::cin&gt;&gt;u&gt;&gt;v;--u,--v;\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n  }\n\n  std::vector&lt;int&gt;F(n),G(n);\n  int ans=0;\n\n  auto dfs=[&amp;](auto self,int u,int f)-&gt;void{\n    std::vector&lt;int&gt;val;\n    for(auto v:adj[u]){\n      if(v==f)continue;\n      self(self,v,u);\n      val.push_back(F[v]);\n    }\n    std::sort(val.begin(),val.end(),std::greater&lt;int&gt;());\n    if(!val.empty())F[u]=1+val[0];\n\n    if(val.size()&gt;=2){\n      G[u]=2+val[0]+val[1];\n    }\n    ans=std::max({ans,F[u],G[u]});\n  };\n\n  dfs(dfs,0,0);\n  std::cout&lt;&lt;ans&lt;&lt;'\\n';\n}\n</code></pre>"},{"location":"dp/dp_probability/","title":"dp for probability","text":"<p>\u67091-6\u7b49\u6982\u7387\u7684\u9ab0\u5b50\uff0c\u6c42\u63b7N\u6b21\u7684\u70b9\u6570\u4e4b\u548c\u4e0d\u5c0f\u4e8eK\u7684\u6982\u7387  </p> <p>\u5bf9\u4e8e\u70b9\u6570\uff0c\u6982\u7387  $ p= \\frac{1}{6} $  </p> <p>\u90a3\u4e48\u6c42\u5f97\u7b2c i \u6b21 \u63b7\u9ab0\u5b50\uff0c\u70b9\u6570\u4e4b\u548c\u4e3a j,j\\le K \u7684 \u6982\u7387  </p> <p>\u7531\u4e8e\u4e8b\u4ef6\u662f\u72ec\u7acb\u7684\uff0c\u90a3\u4e48\u52a0\u6cd5\u5373\u53ef  </p> <p>dp[i+1][min(j+x,K)]+=dp[i][j]/6.0</p> <pre><code>void solve()\n{\n    int N,K;std::cin&gt;&gt;N&gt;&gt;K;\n    std::vector dp(N+1,std::vector(K+1,0.0));\n    dp[0][0]=1.0;\n    for(int i=0;i&lt;N;i++){\n        for(int j=0;j&lt;=K;j++){\n            for(int x=1;x&lt;=6;x++){\n                dp[i+1][std::min(K,j+x)]+=dp[i][j]/6.0;\n            }\n        }\n    }\n    std::cout&lt;&lt;std::fixed&lt;&lt;std::setprecision(12)&lt;&lt;dp[N][K]&lt;&lt;'\\n';\n}\n</code></pre> <p>\u6709\u4e00\u679a\u786c\u5e01\uff0c\u5b58\u5728\u6b63\u53cd\u4e24\u9762\uff0c\u6254\u786c\u5e01N\u6b21\uff0c\u51fa\u73b0\u81f3\u5c11K\u6b21\u8fde\u7eed\u6b63\u9762\u6216\u8005\u53cd\u9762\u7684\u6982\u7387  </p> <p>$P_{\u6b63\u9762}=P_{\u53cd\u9762}= \\frac{1}{2} $  </p> <p>\u5bf9\u4e8e\u8fde\u7eed\u51fa\u73b0\u81f3\u5c11K\u6b21\u7684\u60c5\u51b5\u6709\u591a\u79cd\uff0c\u4e0d\u597d\u7edf\u8ba1\uff0c\u56e0\u4e3a\u8fd9\u79cd\u60c5\u51b5\u53ef\u4ee5\u5206\u6bb5\u3002\u5bf9\u4e8e\u4e0d\u5206\u6bb5\u7684\u60c5\u51b5\u66f4\u597d\u7ef4\u62a4\uff0c\u4e5f\u5c31\u662f\u8fde\u7eed\u51fa\u73b0\u81f3\u591aK-1\u6b21  </p> <p>\u8f6c\u5316\u547d\u9898\uff1aP_{\u81f3\u5c11K\u6b21}=1-P_{\u81f3\u591aK-1\u6b21} </p> <p>\u6c42\u5f97\uff0c\u7b2ci\u6b21\u629b\u786c\u5e01\uff0c\u6709j\u4e2a\u8fde\u7eed\u4e00\u6837\u7684\u6982\u7387 </p> <ul> <li>\u8fde\u7eed\u4e00\u6837: dp[i+1][j+1]+=dp[i][j]/2.0</li> <li>\u4e0d\u4e00\u6837: dp[i+1][1]+=dp[i][j]/2.0 </li> </ul> <p>\u56e0\u4e3a\u7b2c1\u6b21\u629b\u786c\u5e01\u4e00\u5b9a\u67091\u4e2a\u8fde\u7eed\u7684\uff0c\u6240\u4ee5  </p> <p>dp[1][1]=1</p> <pre><code>void solve()\n{\n    int N,K;std::cin&gt;&gt;N&gt;&gt;K;\n    std::vector dp(N+1,std::vector(K+1,0.0));\n    dp[1][1]=1;\n    for(int i=1;i&lt;N;i++){\n        for(int j=0;j&lt;K;j++){\n            if(j+1&lt;K)dp[i+1][j+1]+=dp[i][j]/2.0;\n            dp[i+1][1]+=dp[i][j]/2.0;\n        }\n    }\n    double ans=0;\n    for(int i=0;i&lt;K;i++){\n        ans+=dp[N][i];\n    }\n    std::cout&lt;&lt;std::fixed&lt;&lt;std::setprecision(12)&lt;&lt;1.0-ans&lt;&lt;'\\n';\n}\n\n</code></pre> <p>C - \u30c8\u30fc\u30ca\u30e1\u30f3\u30c8</p> <p>\u6709 2^K\u4eba\u53c2\u52a0K\u8f6e\u7684\u6bd4\u8d5b\uff0c \u6bcf\u4e2a\u4eba\u6709\u8bc4\u7ea7 R_i, \u7b2c P \u4e2a\u4eba\u4e0e\u7b2c Q \u4e2a\u4eba\u6bd4\u8d5b\uff0c\u80dc\u5229\u7684\u6982\u7387\u4e3a: \\frac{1}{1+10^{(R_Q-R_P)/400}} </p> <p>\u6c42\u51fa\u6bcf\u4e2a\u4eba\u6700\u7ec8\u80dc\u5229\u7684\u6982\u7387  </p> <p>\u7b2ci\u4eba\u80dc\u5229 \\rightarrow \u7b2ci\u4eba\u5728\u7b2cK\u8f6e\u540e\u4ecd\u7136\u6d3b\u7740 </p> <p>dp[i][k] := \u7b2ci\u4eba\u5728\u7b2ck\u8f6e\u7ed3\u675f\u540e\u6d3b\u4e0b\u6765\u7684\u6982\u7387  </p> <ul> <li>\u6700\u521d\u6bcf\u4e2a\u4eba\u90fd\u6d3b\u7740: dp[i][0]=1.0</li> <li>\u9884\u5148\u8ba1\u7b97\u7b2c i \u4eba\u4e0e\u7b2c j \u4eba\u6bd4\u8d5b\u80dc\u5229\u7684\u53ef\u80fd\u6027\u4e3a P_{i,j} </li> <li>\u8bb0\u7b2ck\u8f6e\uff0c\u8fd8\u5269\u4e0b\u7684\u4eba\u7684\u96c6\u5408\u4e3a S_{i,k} </li> <li>dp[i][k]=\\sum_{j\\in S_{i,k}} dp[i][k-1]\\times dp[j][k-1] \\times P_{i,j} </li> </ul> <pre><code>void solve()\n{\n  int N,K;std::cin&gt;&gt;K;\n  N=1&lt;&lt;K;\n  std::vector dp(N,std::vector(K+1,0.0));\n  std::vector&lt;double&gt;R(N);\n  for(auto&amp;x:R)std::cin&gt;&gt;x;\n  for(int i=0;i&lt;N;i++)dp[i][0]=1.0;\n\n  std::vector P(N,std::vector(N,0.0));\n\n  auto calc=[&amp;](int i,int j){\n    return 1.0/(1.0+std::pow(10.0,(R[j]-R[i])/400.0));\n  };\n\n  for(int i=0;i&lt;N;i++){\n    for(int j=0;j&lt;N;j++){\n      P[i][j]=calc(i,j);\n    }\n  }\n\n\n  for(int k=1;k&lt;=K;k++){\n    for(int i=0;i&lt;N;i++){\n      int lb=(i&gt;&gt;k)&lt;&lt;k;\n      for(int j=lb;j&lt;lb+(1&lt;&lt;k);j++){\n        if((i&gt;&gt;(k-1)&amp;1)==(j&gt;&gt;(k-1)&amp;1))continue;\n        dp[i][k]+=dp[i][k-1]*dp[j][k-1]*P[i][j];\n      }\n    }\n  }\n\n  std::cout&lt;&lt;std::fixed&lt;&lt;std::setprecision(12);\n  for(int i=0;i&lt;N;i++){\n    std::cout&lt;&lt;dp[i][K]&lt;&lt;'\\n';\n  } \n}\n</code></pre>"},{"location":"dp/range_dp/","title":"Range dp","text":"<p>N - Slimes</p> <p>N \u4e2a\u6570\uff0c\u6bcf\u6b21\u5408\u5e76\u76f8\u90bb\u7684\u4e24\u4e2a\u6570 </p> <p>\u5408\u5e76\u4e4b\u540e\u7684\u6570\u4e3a\u4e24\u6570\u4e4b\u548cx+y\uff0c\u8d39\u7528\u4e3ax+y</p> <p>\u95ee\u5c06\u6240\u6709\u6570\u5408\u5e76\u4e4b\u540e\u7684\u6700\u5c0f\u8d39\u7528 </p> <p>\u5982\u679c\u73b0\u5728\u5904\u7406\u7684\u662f\u533a\u95f4[l,r]</p> <p>\u679a\u4e3e\u5206\u5272\u70b9m\uff0c\u901a\u8fc7\u5206\u5272\u70b9m\u6240\u5f97\u5230\u7684\u6700\u5c0f\u82b1\u8d39\u4e3a:</p> <p>f(l,m)+f(m+1,r)+\\sum_{i=l}^{r}a_i</p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing i64 = long long;\nvoid solve()\n{\n    int N;std::cin&gt;&gt;N;\n\n    std::vector&lt;i64&gt;a(N+1);\n    for(int i=1;i&lt;=N;i++)std::cin&gt;&gt;a[i];\n\n    const i64 INF=1e18;\n    std::vector dp(N+1,std::vector&lt;i64&gt;(N+1,INF));\n    std::vector vis(N+1,std::vector&lt;bool&gt;(N+1,false));\n\n    std::vector&lt;i64&gt;pre(N+1);\n    for(int i=1;i&lt;=N;i++)pre[i]=pre[i-1]+a[i];\n\n    auto dfs = [&amp;](auto self, int L, int R) -&gt; i64 {\n        if (L == R)\n            return 0;\n        if(vis[L][R])\n            return dp[L][R];\n        vis[L][R]=true;\n\n        i64 ans=INF;\n        for(int i=L;i&lt;R;i++){\n            ans=std::min({ans,self(self,L,i)+self(self,i+1,R)});\n        }\n        i64 sum=pre[R]-pre[L-1];\n        return dp[L][R]=ans+sum;\n    };\n\n    std::cout&lt;&lt;dfs(dfs,1,N)&lt;&lt;'\\n';\n}\nint main()\n{\n    std::cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    solve();\n    return 0;\n}\n\n</code></pre> <p>1039. \u591a\u8fb9\u5f62\u4e09\u89d2\u5256\u5206\u7684\u6700\u4f4e\u5f97\u5206</p> <p>\u4f60\u6709\u4e00\u4e2a\u51f8\u7684 n \u8fb9\u5f62\uff0c\u5176\u6bcf\u4e2a\u9876\u70b9\u90fd\u6709\u4e00\u4e2a\u6574\u6570\u503c\u3002\u7ed9\u5b9a\u4e00\u4e2a\u6574\u6570\u6570\u7ec4 values \uff0c\u5176\u4e2d values[i] \u662f\u7b2c i \u4e2a\u9876\u70b9\u7684\u503c\uff08\u5373 \u987a\u65f6\u9488\u987a\u5e8f \uff09\u3002</p> <p>\u5047\u8bbe\u5c06\u591a\u8fb9\u5f62 \u5256\u5206 \u4e3a n - 2 \u4e2a\u4e09\u89d2\u5f62\u3002\u5bf9\u4e8e\u6bcf\u4e2a\u4e09\u89d2\u5f62\uff0c\u8be5\u4e09\u89d2\u5f62\u7684\u503c\u662f\u9876\u70b9\u6807\u8bb0\u7684\u4e58\u79ef\uff0c\u4e09\u89d2\u5256\u5206\u7684\u5206\u6570\u662f\u8fdb\u884c\u4e09\u89d2\u5256\u5206\u540e\u6240\u6709 n - 2 \u4e2a\u4e09\u89d2\u5f62\u7684\u503c\u4e4b\u548c\u3002</p> <p>\u8fd4\u56de \u591a\u8fb9\u5f62\u8fdb\u884c\u4e09\u89d2\u5256\u5206\u540e\u53ef\u4ee5\u5f97\u5230\u7684\u6700\u4f4e\u5206</p> <p>\u5982\u679c\u5df2\u7ecf\u786e\u5b9a\u4e24\u4e2a\u4e09\u89d2\u5f62\u7684\u4e24\u4e2a\u7aef\u70b9,\u90a3\u4e48\u679a\u4e3e\u7b2c\u4e09\u4e2a\u7aef\u70b9\u5373\u53ef\u5f97\u5230\u4e00\u4e2a\u4e09\u89d2\u5f62 </p> <p>dp(i,j):\u4ece i \u5230j\u7684\u591a\u8fb9\u5f62\u7684\u6700\u4f4e\u5f97\u5206</p> <p>dp(i,j)=\\max_{k=i+1}^{j-1}(dp(i,k)+dp(k,j)+v(i)*v(j)*v(k))</p> <pre><code>class Solution {\npublic:\n    int minScoreTriangulation(vector&lt;int&gt;&amp; values) {\n        int n=values.size();\n        std::vector dp(n+1,std::vector&lt;int&gt;(n+1,0));\n        std::vector vis(n+1,std::vector&lt;bool&gt;(n+1,false));\n        const int INF=1e9;\n        auto dfs=[&amp;](auto self,int i,int j)-&gt;int{\n            if(i+1==j){\n                return 0;\n            }\n            if(vis[i][j])return dp[i][j];\n            vis[i][j]=true;\n            int ans=INF;\n            for(int k=i+1;k&lt;j;k++){\n                ans=std::min(ans,self(self,i,k)+self(self,k,j)+values[i]*values[j]*values[k]);\n            }\n            return dp[i][j]=ans;\n        };\n\n        return dfs(dfs,0,n-1);\n    }\n};\n</code></pre>"},{"location":"math/GCD_Convolution/","title":"GCD Convolution","text":""},{"location":"math/GCD_Convolution/#zeta","title":"\u7ea6\u6570\u7cfb\u4e0b\u7684zeta\u53d8\u6362","text":"<p>F(n)=\\sum_{n|i}f(i),1\\le n\\le N </p>"},{"location":"math/GCD_Convolution/#mobius","title":"\u7ea6\u6570\u7cfb\u4e0b\u7684mobius\u53d8\u6362","text":"<p>f(n)=\\sum_{n|i}\\mu(\\frac{i}{n})F(i),1\\le n\\le N</p> <p>N=12\u65f6</p> <p>F(i)</p> <ul> <li>F(1)=f(1)+f(2)+\\ldots f(10) </li> <li>F(2)=f(2)+f(4)+f(6)+f(8)+f(10)+f(12) </li> <li>F(3)=f(3)+f(6)+f(9)+f(12) </li> <li>F(4)=f(4)+f(8)+f(12) </li> <li>F(5)=f(5)+f(10) </li> <li>F(6)=f(6)+f(12) </li> <li>F(7)=f(7) </li> <li>F(8)=f(8) </li> <li>F(9)=f(9) </li> <li>F(10)=f(10)</li> <li>F(11)=f(11) </li> <li>F(12)=f(12) </li> </ul> <p>f(i) </p> <ul> <li>f(1)=F(1)-F(2)-F(3)-F(5)-F(7)-F(11)+F(6)+F(10) </li> <li>f(2)=F(2)-F(4)-F(6)-F(10)+F(12) </li> <li>f(3)=F(3)-F(6)-F(9) </li> <li>f(4)=F(4)-F(8)-F(12) </li> <li>f(5)=F(5)-F(10) </li> <li>f(6)=F(6)-F(12) </li> <li>f(7)=F(7)</li> <li>f(8)=F(8) </li> <li>f(9)=F(9) </li> <li>f(10)=F(10) </li> <li>f(11)=F(11) </li> <li>f(12)=F(12) </li> </ul> <p>zeta\u53d8\u6362\u5c31\u662f\u7d2f\u79ef\u548c\uff0cmobius\u53d8\u6362\u5c31\u662f\u5dee\u5206</p>"},{"location":"math/GCD_Convolution/#gcd","title":"gcd\u5377\u79ef","text":"<p>h(n)=\\sum_{\\gcd(i,j)=n}f(i)g(j) </p>"},{"location":"math/GCD_Convolution/#_1","title":"\u524d\u7f6e\u53cd\u6f14\u7ed3\u8bba","text":"[n=1]=\\epsilon(n)=\\sum_{d|n}\\mu(d) \\\\ =\\sum_{\\substack{d=1\\\\ d|n}}^{n}\\mu(d)=\\sum_{d=1}^{n}\\mu(d)[d|n] \\\\"},{"location":"math/GCD_Convolution/#example","title":"example","text":"f=\\sum_{i=1}^{N}\\sum_{j=1}^{N}[\\gcd(i,j)=1]\\\\ \u8ba1\u7b97\u8fd9\u4e2a\u5f0f\u5b50\uff0c\u901a\u5e38\u4f7f\u7528\u4e0a\u9762\u7684\u53cd\u6f14\u7ed3\u8bba:\\\\ [gcd(i,j)=1]=\\sum_{d|\\gcd(i,j)}\\mu(d) \\\\ f=\\sum_{i=1}^{N}\\sum_{j=1}^{N}\\sum_{d|\\gcd(i,j)}\\mu(d)\\\\ =\\sum_{i=1}^{N}\\sum_{j=1}^{N}\\sum_{\\substack{d|i\\\\ d|j}}\\mu(d)\\\\ =\\sum_{i=1}^{N}\\sum_{j=1}^{N}\\sum_{d=1}^{N}\\mu(d)[d|i][d|j]\\\\ =\\sum_{d=1}^{N}\\mu(d)\\sum_{i=1}^{N}[d|i]\\sum_{j=1}^{N}[d|j]\\\\ =\\sum_{d=1}^{N}\\mu(d)\\left\\lfloor\\frac{N}{d}\\right\\rfloor^{2}\\\\ \u4e0b\u9762\u4f7f\u7528gcd\u5377\u79ef:\\\\ f=h(1)=\\sum_{\\gcd(i,j)=1}f(i)f(j)\\\\ f(i):[1,N]\u6709\u51e0\u4e2a\u6570\u7b49\u4e8ei\\\\ \u663e\u7136f(i)=1,1\\le i\\le N\\\\  <pre><code>void solve()\n{   \n    int n;\n    std::cin&gt;&gt;n;\n    std::vector&lt;Z&gt; f(n + 1, 1);\n    auto h = gcd_conv(f, f);\n    Z ans = 0;\n\n    for (int d = 1; d &lt;= n; d++) {\n      ans += Z(mobius[d]) * Z((n / d)).pow(2);\n    }\n\n    if (ans != h[1]) {\n      std::cout &lt;&lt; \"NO\\n\";\n      std::cout &lt;&lt; n &lt;&lt; '\\n';\n      std::cout &lt;&lt; ans &lt;&lt; ' ' &lt;&lt; h[1] &lt;&lt; '\\n';\n      return;\n    }\n}\n</code></pre> <p>P1390 \u516c\u7ea6\u6570\u7684\u548c</p> <p>\\sum_{i=1}^{n}\\sum_{j=i+1}^{n}\\gcd(i,j) </p> <p>\u9996\u5148\u4e0a\u9762\u7684\u5f0f\u5b50\u7edf\u8ba1\u4e86 1\\le i&lt;j\\le n </p> <p>\u8fd9\u5e76\u4e0d\u597d\u5904\u7406</p> <p>\u6211\u4eec\u77e5\u9053: 1\\le i,j\\le n \u548c 1\\le i=j \\le n \u662f\u66f4\u597d\u5904\u7406\u7684  </p> <p>\u524d\u8005\u4e0d\u8003\u8651 (i,j) \u7684\u987a\u5e8f  </p> <p>\u540e\u8005\u53ea\u9700\u8003\u8651 i=j </p> <p>\u90a3\u4e48\u540e\u8005 \u8bb0\u4e3a(S_y):</p> <p>\\sum_{i=1}^{n}gcd(i,i)</p> <p>=\\sum_{i=1}^{n}i </p> <p>=\\frac{(1+n)n}{2}</p> <p>\u524d\u8005 \u8bb0\u4e3a(S_x):</p>  \u8bbef(i)=1,1\\le i\\le n\\\\ \\sum_{i=1}^{n}\\sum_{j=1}^{n}\\gcd(i,j)\\\\ =\\sum_{g=1}^{n}\\sum_{\\gcd(i,j)=g}g\\times f(i)f(j)\\\\ =\\sum_{g=1}^{n}g\\sum_{\\gcd(i,j)=g}f(i)f(j)\\\\ \u7531\\gcd\u5377\u79ef\u5f97:\\\\ \u4e0a\u5f0f=\\sum_{g=1}^{n}h(g)\\times g  <p>\u7b54\u6848\u5373\u4e3a: \\frac{(S_x-S_y)}{2}</p> <pre><code>void solve()\n{   \n    int n;\n    std::cin&gt;&gt;n;\n    std::vector&lt;i64&gt; f(n + 1,1);\n\n    auto h = gcd_conv(f, f);\n\n    i64 ans=-1LL*(n+1)*n/2LL;\n    for(int i=1;i&lt;=n;i++){\n        ans+=1LL*h[i]*i;\n    }\n    ans/=2;\n    std::cout&lt;&lt;ans&lt;&lt;'\\n';\n}\n</code></pre> <p>P3911 \u6700\u5c0f\u516c\u500d\u6570\u4e4b\u548c</p> <p>\\sum_{i=1}^{N}\\sum_{j=1}^{N}lcm(A_i,A_j)</p>  \u539f\u5f0f=\\sum_{1\\le i,j\\le N}\\frac{A_i\\times A_j}{\\gcd(A_i,A_j)}\\\\ =\\sum_{g=1}^{N}\\sum_{\\substack{\\gcd(A_i,A_j)=g\\\\1\\le i,j\\le N}}\\frac{A_i\\times A_j}{g}\\\\ \u8bbeu=A_i,v=A_j,MX=\\max(A) \\\\ \u8bbef(u)=u\\times cnt(u),cnt(u):[1,MX]\u4e2d\uff0cu\u7684\u4e2a\u6570\\\\ \u7531gcd\u5377\u79ef:\\quad h(g)=\\sum_{\\gcd(u,v)=g}f(u)f(v)\\\\ \u539f\u5f0f=\\sum_{g=1}^{MX}\\frac{h(g)}{g}\\\\  <pre><code>void solve()\n{   \n    int n;\n    std::cin&gt;&gt;n;\n    std::vector&lt;int&gt;a(n);\n    for(auto&amp;x:a)std::cin&gt;&gt;x;\n\n    int MX=*std::max_element(a.begin(),a.end());\n\n    std::vector&lt;i64&gt;f(MX+1);\n\n    for(auto x:a){\n        f[x]++;\n    }\n\n    for(int i=0;i&lt;=MX;i++){\n        f[i]*=i;\n    }\n\n    auto h=gcd_conv(f, f);\n\n    i64 ans=0;\n    for(int i=1;i&lt;=MX;i++){\n        ans+=h[i]/i;\n    }\n    std::cout&lt;&lt;ans&lt;&lt;'\\n';\n}\n</code></pre>"},{"location":"math/GCD_Convolution/#_2","title":"\u7ec3\u4e60","text":"<p>C - LCMs</p>"},{"location":"math/GCD_Convolution/#_3","title":"\u6a21\u677f\u4ec5\u4f9b\u53c2\u8003","text":"<pre><code>const int N=1e6+1e3;\nstd::vector&lt;int&gt;prime;\nstd::vector&lt;bool&gt;is_prime(N+1,true);\nstd::vector&lt;int&gt;mobius(N+1,1);\n\nvoid sieve(){\n    is_prime[0]=is_prime[1]=false;\n    for(int p=2;p&lt;=N;p++){\n        if(!is_prime[p])continue;\n        prime.push_back(p);\n        mobius[p]=-1;\n        for(int q=2*p;q&lt;=N;q+=p){\n            is_prime[q]=false;\n            if((q/p)%p==0)mobius[q]=0;\n            else mobius[q]=-mobius[q];\n        }\n    }\n}\n\ntemplate&lt;typename T&gt;\nstd::vector&lt;T&gt; fast_zeta(std::vector&lt;T&gt;F){\n    int n=F.size();\n    for(int p=2;p&lt;n;p++){\n        if(!is_prime[p])continue;\n        for(int k=(n-1)/p;k&gt;=1;k--){\n            F[k]+=F[k*p];\n        }\n    }\n    return F;\n}\n\ntemplate&lt;typename T&gt;\nstd::vector&lt;T&gt; fast_mobius(std::vector&lt;T&gt;f){\n    int n=f.size();\n    for(int p=2;p&lt;n;p++){\n        if(!is_prime[p])continue;\n        for(int k=1;k*p&lt;n;k++){\n            f[k]-=f[k*p];\n        }\n    }\n    return f;\n}\n\ntemplate&lt;typename T&gt;\nstd::vector&lt;T&gt; gcd_conv(const std::vector&lt;T&gt;&amp;f,const std::vector&lt;T&gt;&amp;g){\n    int n=std::max(f.size(),g.size());\n    auto F=fast_zeta(f);\n    auto G=fast_zeta(g);\n    std::vector&lt;T&gt;H(n);\n    for(int i=1;i&lt;n;i++)H[i]=F[i]*G[i];\n    return fast_mobius(H);\n}\n</code></pre>"},{"location":"miscellaneous/two_pointer/","title":"Two pointer","text":"<p>\u5728\u957f\u5ea6\u4e3a N\u7684\u6570\u5217\uff0ca_1,a_2,\\ldots,a_n \u4e2d </p> <ul> <li>\u6ee1\u8db3 \u6761\u4ef6 \u7684 \u6700\u77ed \u8fde\u7eed\u5b50\u5e8f\u5217</li> <li>\u6ee1\u8db3 \u6761\u4ef6 \u7684 \u6700\u957f \u8fde\u7eed\u5b50\u5e8f\u5217</li> <li>\u6ee1\u8db3 \u6761\u4ef6 \u7684 \u8fde\u7eed\u5b50\u5e8f\u5217\u7684 \u4e2a\u6570 </li> </ul> <p>The Number of Windows</p> <p>\u6c42\u5f97\u6ee1\u8db3\u6761\u4ef6: \\sum_{i=l}^{r}a_i \\le X \u7684\u533a\u95f4[l,r] \u4e2a\u6570 </p> <p>\u5c1d\u8bd5\u56fa\u5b9a\u5de6\u7aef\u70b9 l,\u7136\u540e\u79fb\u52a8\u53f3\u7aef\u70b9 r </p> <p>\u5f53\\ r\\ \u79fb\u52a8\u5230\u7b2c\u4e00\u4e2a\u4e0d\u6ee1\u8db3\u6761\u4ef6\u7684\u4e0b\u6807\u65f6\uff0c\u4e5f\u5c31\u662f\u533a\u95f4\u52a0\u548c &gt; X\u65f6</p> <p>\u53d1\u73b0\u8fd9\u4e9b\u533a\u95f4\\ [l,i]\\ i \\in [l,r)\u4e00\u5b9a\u662f\u7b26\u5408\u8981\u6c42\u7684 </p> <p>\u8fd9\u4e9b\u533a\u95f4\u4e00\u5171\u6709: r-l \u4e2a</p> <p>\u6bcf\u6b21\u56fa\u5b9a\u5de6\u7aef\u70b9l,\u7136\u540e\u627e\u5230\u7b2c\u4e00\u4e2a\u4e0d\u7b26\u5408\u6761\u4ef6\u7684\u53f3\u7aef\u70b9r,\u662f\u7ecf\u5178\u7684\u4e8c\u5206\u641c\u7d22\uff0cO(N\\log N) </p> <p>\u4f46\u662f\u53ef\u4ee5\u53d1\u73b0\u9010\u6e10\u79fb\u52a8\u5de6\u7aef\u70b9l,\u53f3\u7aef\u70b9r\u53ea\u4f1a\u5411\u540e\u79fb\u52a8 </p> <p>l,r\u90fd\u53ea\u4f1a\u79fb\u52a8 N\u6b21,\u6240\u4ee5\u8fd9\u662f\u4e00\u4e2aO(N)\u7b97\u6cd5</p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing i64 = long long;\nvoid solve()\n{\n    int N,Q;\n    std::cin&gt;&gt;N&gt;&gt;Q;\n    std::vector&lt;i64&gt;a(N);\n    for(auto&amp;x:a)std::cin&gt;&gt;x;\n\n    while(Q--){\n        i64 x;std::cin&gt;&gt;x;\n        i64 ans=0;\n        i64 sum=0;\n        for(int i=0,j=0;i&lt;N;i++){\n            while(j&lt;N and sum+a[j]&lt;=x){\n                sum+=a[j++];\n            }\n            ans+=j-i;\n            if(i==j)j++;\n            else sum-=a[i];\n        }\n        std::cout&lt;&lt;ans&lt;&lt;'\\n';\n    }\n}\nint main()\n{\n    std::cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    solve();\n    return 0;\n}\n</code></pre> <p>Subsequence</p> <p>\u6c42\u5f97\u6ee1\u8db3:\\sum_{i=l}^{r}a_i \\ge S,\\min({r-l+1}) </p> <p>\u56fa\u5b9a\u5de6\u7aef\u70b9l,\u79fb\u52a8\u53f3\u7aef\u70b9r,\u5f53sum \\ge S\u65f6,r\u662f\u7b2c\u4e00\u4e2a\u4e0d\u7b26\u5408\u6761\u4ef6\u7684\u7aef\u70b9 </p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n// using i64 = long long;\ntypedef i64 long long;\nvoid solve()\n{\n    int N;i64 S;\n    std::cin&gt;&gt;N&gt;&gt;S;\n    std::vector&lt;i64&gt;a(N);\n    for(int i=0;i&lt;N;i++)std::cin&gt;&gt;a[i];\n    int ans=N+1;\n    i64 sum=0;\n    for(int i=0,j=0;i&lt;N;i++){\n        while(j&lt;N and sum&lt;S){\n            sum+=a[j++];\n        }\n        if(sum&lt;S)break;\n        ans=std::min(ans,j-i);\n        if(i==j)j++;\n        else{\n            sum-=a[i];\n        }\n    }\n    std::cout&lt;&lt;(ans==N+1?0:ans)&lt;&lt;'\\n';\n}\nint main()\n{\n    // std::cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    int t;\n    std::cin &gt;&gt; t;\n    while (t--)\n    {\n        solve();\n    }\n    return 0;\n}\n\n</code></pre> <p>C - \u5217</p> <p>\u6c42\u5f97\u6ee1\u8db3:\\ \\prod_{i=l}^{r}s_i \\le K,\\max({r-l+1}) </p> <p>\u7531\u4e8e\u662f\u6c42\u6700\u957f\u6ee1\u8db3\u6761\u4ef6\u5e8f\u5217\u957f\u5ea6\uff0c\u90a3\u4e48\u5982\u679c\u6570\u7ec4\u4e2d\u5305\u542b0\uff0c\u90a3\u4e48\u7b54\u6848\u5373\u4e3a\u5e8f\u5217\u957f\u5ea6 N </p> <p>\u5426\u5219\uff0c\u5f53mul &gt; K \u65f6,\u53f3\u7aef\u70b9r\u56fa\u5b9a </p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing i64 = long long;\nvoid solve()\n{\n  int N,K;\n  std::cin&gt;&gt;N&gt;&gt;K;\n  std::vector&lt;i64&gt;a;\n  bool zero=false;\n  for(int i=0;i&lt;N;i++){\n    i64 x;std::cin&gt;&gt;x;\n    if(x==0)zero=true;\n    else a.push_back(x);\n  }\n  if(zero){\n    std::cout&lt;&lt;N&lt;&lt;'\\n';\n    return;\n  }\n\n  int ans=0;\n  i64 mul=1;\n  for(int i=0,j=0;i&lt;N;i++){\n    while (j &lt; N and (mul * a[j] &lt;= K)) {\n      mul*=a[j++];\n    }\n    ans=std::max(ans,j-i);\n    if(i==j)j++;\n    else{\n      mul /= a[i];\n    }\n  }\n  std::cout&lt;&lt;ans&lt;&lt;'\\n';\n}\nint main()\n{\n    std::cin.tie(nullptr)-&gt;sync_with_stdio(false);\n    solve();\n}\n</code></pre> <p>C - \u5358\u8abf\u5897\u52a0</p>"},{"location":"problem/The_Gourmet/","title":"The Gourmet","text":"<p>The Gourmet</p> <p>\u4e00\u5171\u6709 M \u5206\u949f\uff0cN \u4e2a\u83dc\uff0c\u7b2c i \u9053\u83dc\u9700\u8981\u5403 T_i \u5206\u949f  </p> <p>\u6c42\u51fa\u521a\u597d\u5403 M \u5206\u949f\u7684\u5403\u83dc\u65b9\u6848\uff0c\u533a\u5206\u987a\u5e8f  </p> <p>\u5b8c\u5168\u80cc\u5305+\u533a\u522b\u987a\u5e8f  </p> <p>\u65e2\u7136\u9700\u8981\u533a\u522b\u987a\u5e8f\uff0c\u90a3\u4e48\u7531\u80cc\u5305\u4ece\u5c0f\u5230\u5927\u66f4\u65b0\u65b9\u6848\u6570\u5373\u53ef  </p> <p>\u53cd\u4e4b\u4e0d\u533a\u5206\u987a\u5e8f\u5219\u7531\u7269\u54c1\u987a\u5e8f\u66f4\u65b0</p> <p>\u4e5f\u5c31\u662f\u533a\u522b\u5148\u679a\u4e3e\u5bb9\u91cf\u8fd8\u662f\u5148\u679a\u4e3e\u7269\u54c1  </p> <pre><code>using i64 = long long;\nvoid solve() {\n  int M,N;\n  std::cin&gt;&gt;M&gt;&gt;N;\n  std::vector&lt;int&gt;t(N);\n  for(auto&amp;x:t){\n    std::cin&gt;&gt;x;\n  }\n  std::vector&lt;int&gt;dp(M+1,0);\n  dp[0]=1;\n  for(int i=0;i&lt;=M;i++){\n    for(int j=0;j&lt;N;j++){\n      int k=i-t[j];\n      if(k&gt;=0 &amp;&amp; dp[k]){\n        dp[i]+=dp[k];\n      }\n    }\n  }\n  std::cout&lt;&lt;dp[M]&lt;&lt;'\\n';\n}\n</code></pre>"}]}